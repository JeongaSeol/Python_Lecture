# Python CH.11 데이터 분석을 위한 패키지

# NumPy & Pandas



## 11.1 NumPy : 배열 데이터를 효과적으로 다루기

> python에서 과학 연산을 효율적으로 할 수 있도록 외부 패키지인 NumPy를 사용
>
> python의 기본 데이터 형식이나 내장 함수를 이용하는 것보다 다차원 배열 데이터를 효과적으로 처리 가능
>
> NumPy에 대한 정보 :  [NumPy홈페이지](http://www.numpy.org)

- #### 배열 생성하기

  - 배열(Array) : 같은 종류의 데이터들이 순서대로 저장된 집합
  - NumPy로 배열을 처리하기 위해서는 NumPy로 배열을 생성해야함
  - 설치된 NumPy를 이용하기 위해서는 먼저 NumPy 패키지를 불러와야 함
    - 한 번만 불러오면 코드 내에서는 NumPy 사용 가능
  - `import numpy as 별명` : NumPy 패키지를 불러오고 이를 `별명`으로 호출 할 수 있음

  ```python
  import numpy as np 			# numpy 패키지를 불러오고 이를 np로 지정함
  ```

  - `arr_obj = np.array(seq_data)` 
    - 시퀀스 데이터`seq_data`를 인자로 받아 NumPy의 배열 객체를 생성 후, `arr_obj`에 저장함
    - 시퀀스 데이터`seq_data`로는 list, tuple 타입의 데이터를 모두 사용 가능(주로 list를 이용)
    - 정수와 실수가 혼합이 되어 있다면 모두 실수로 변환하여 실수 배열을 생성함

  ```python
  ## list로부터 NumPy의 1차원 배열을 생성
  ----------------------------<코드>----------------------------
  
  import numpy as np
  
  data1 = [0, 1, 2, 3, 4, 5]		# 리스트를 생성
  a1 = np.array(data1)			# 생성한 리스트를 array()인자로 넣어 NumPy 배열 생성
  a1
  
  ----------------------------<결과>----------------------------
  array([0, 1, 2, 3, 4, 5])
  ```

  ```python
  ## 실수와 정수가 혼합되어 있는 리스트 데이터로 NumPy 배열 생성
  ----------------------------<코드>----------------------------
  
  data2 = [0, 1.5, 2, 3.7, 4, 5.2]		# 실수와 정수가 혼합되어 있는 리스트
  a2 = np.array(data2)			
  a2
  
  ----------------------------<결과>----------------------------
  array([0. , 1.5, 2. , 3.7, 4. , 5.2])	# 정수 또한 모두 실수로 변환되어 실수 배열이 생성됨
  ```

  - `arr_obj = np.array([list])`
    - `array()`함수 인자로 직접 리스트 데이터를 넣어서 배열 객체를 생성 할 수 있음
    - 인자에 `[[list_data], [list_data], ... , [list_data]]`로 넣어 다차원 배열도 생성 가능

  ```python
  ## array()에 인자로 직접 리스트 데이터를 넣어서 배열 객체 생성
  ----------------------------<코드>----------------------------
  
  a3 = np.array([0.5, 2, 0.01, 8])
  a3
  
  ----------------------------<결과>----------------------------
  array([0.5 , 2.  , 0.01, 8.  ])
  ```

  ```python
  ## array()를 이용하여 다차원 배열 객체 생성
  ----------------------------<코드>----------------------------
  
  a4 = np.array([[1,2,3], [4,5,6]])		# 2차원(2X3) 배열 생성
  a4
  
  ----------------------------<결과>----------------------------
  array([[1, 2, 3],
         [4, 5, 6]])
  ```

  - `arr_obj = np.arange([start,] stop [,step])`
    - `start`부터 시작해서 `stop`전까지(`stop - 1` 까지) `step`만큼 더해서 NumPy 배열을 생성
    - `start`는 0인 경우 생략 가능,  `step`은 1인 경우 생략 가능

  ```python
  ## np.arange() 사용해서 배열 생성
  ----------------------------<코드>----------------------------
  
  ar1 = np.arange(0,10,2)		# 0부터 9까지 2씩 더한 수들로 배열 생성
  ar2 = np.arange(1,10)		# step 생략하고 1부터 9까지 1씩 더한 수들로 배열 생성
  ar3 = np.arange(5)			# star, step 생략하고 0부터 4까지 1씩 더한 수들로 배열 생성
  
  print(ar1)
  print(ar2)
  print(ar3)
  
  ----------------------------<결과>----------------------------
  [0 2 4 6 8]
  [1 2 3 4 5 6 7 8 9]
  [0 1 2 3 4]
  ```

  - `arr_obj = np.arange().reshape(m,n)`
    - `arange()`로 만든 1차원 배열에 `reshape(m,n)`을 추가하여 m x n 형태의 2차원 배열(행렬)로 변경
    - NumPy 배열에서 행과 열의 위치(index)는 0부터 시작
    - `arange()`로 생성되는 원소 개수와 `reshape(m,n)`에서의 m x n 개수는 같아야함
    - `arr_obj.shape` : 배열의 형태를 확인

  ```python
  ## np.arange().reshape(m,n)을 이용하여 2차원 배열 생성
  ----------------------------<코드>----------------------------
  
  ar4 = np.arange(12).reshape(4,3)	# 0부터 11까지 12개의 원소를 4x3행렬(배열)로 생성
  ar5 = np.arange(1,10).reshape(3,3)	# 1부터 9까지 9개의 원소를 3x3 배열로 생성
  ar6 = np.arange(1,24,2).reshape(2,6) # 1부터 23까지 2씩 건너뛰며 만든 12개의 원소로 2x6 배열
  ar7 = np.arange(10)			# 0부터 9까지 10개의 원소를 1차원 배열로 생성
  
  print(ar4)
  print(ar4.shape, '\n')		# 배열의 형태 확인
  print(ar5)
  print(ar5.shape, '\n')
  print(ar6)
  print(ar6.shape, '\n')
  print(ar7)
  print(ar7.shape)
  
  
  ----------------------------<결과>----------------------------
  [[ 0  1  2]
   [ 3  4  5]
   [ 6  7  8]
   [ 9 10 11]]
  (4, 3) 
  
  [[1 2 3]
   [4 5 6]
   [7 8 9]]
  (3, 3) 
  
  [[ 1  3  5  7  9 11]
   [13 15 17 19 21 23]]
  (2, 6) 
  
  [0 1 2 3 4 5 6 7 8 9]
  (10,)					# 1차원 배열의 형태는 (n, )로 출력
  ```

  - `arr_obj = np.linspace(start, stop[, num])` 
    - 범위의 시작과 끝을 지정하고 데이터의 개수를 지정해 NumPy 배열을 생성
    - `start`부터 `stop`까지 `num`개의 NumPy 배열을 생성함
    - `num`은 생략 가능하며, 생략시에는 50으로 default

  ```python
  ## np.linspace()함수를 이용하여 배열 생성
  ----------------------------<코드>----------------------------
  
  lar1 = np.linspace(1, 10, 10)	# 1부터 10까지 10개의 데이터로 1차원 배열 생성
  lar2 = np.linspace(0, np.pi, 20)  # 0부터 pi(3.141592..)까지 동일한 간격으로 나눈 20개의 
  								  # 데이터로 1차원 배열 새성
  lar3 = np.linspace(1,12,12).reshape(3,4)	# 12개의 데이터로 3x4 2차원 배열 생성
  
  print(lar1)
  print(lar2)
  print(lar3)
  
  ----------------------------<결과>----------------------------
  [ 1.  2.  3.  4.  5.  6.  7.  8.  9. 10.]
  
  [0.         0.16534698 0.33069396 0.49604095 0.66138793 0.82673491
   0.99208189 1.15742887 1.32277585 1.48812284 1.65346982 1.8188168
   1.98416378 2.14951076 2.31485774 2.48020473 2.64555171 2.81089869
   2.97624567 3.14159265]
  
  [[ 1.  2.  3.  4.]
   [ 5.  6.  7.  8.]
   [ 9. 10. 11. 12.]]
  ```

  - `np.zeros(n)` / `np.zeros((m,n))`
    - 모든 원소가 0인 1차원 / 2차원(mxn) 배열 생성	
  - `np.ones(n)` / `np.ones((m,n))`
    - 모든 원소가 1인 1차원 / 2차원(mxn) 배열 생성

  ```python
  ## 모든 원소가 0인 배열 생성
  ----------------------------<코드>----------------------------
  
  arz1 = np.zeros(5)
  arz2 = np.zeros((5,3))
  
  print(arz1)
  print(arz2)
  
  ----------------------------<결과>----------------------------
  [0. 0. 0. 0. 0.]		# np.zeros()에서 원소 0은 정수가 아닌 실수
  
  [[0. 0. 0.]
   [0. 0. 0.]
   [0. 0. 0.]
   [0. 0. 0.]
   [0. 0. 0.]]
  ```

  ```python
  ## 모든 원소가 1인 배열 생성
  ----------------------------<코드>----------------------------
  
  aro1 = np.ones(4)
  aro2 = np.ones((4,6))
  
  print(aro1)
  print(aro2)
  
  ----------------------------<결과>----------------------------
  [1. 1. 1. 1.]			# np.ones()에서 원소1은 정수가 아닌 실수
  
  [[1. 1. 1. 1. 1. 1.]
   [1. 1. 1. 1. 1. 1.]
   [1. 1. 1. 1. 1. 1.]
   [1. 1. 1. 1. 1. 1.]]
  ```

  - `np.eye(n)` 
    - nxn 단위행렬을 갖는 2차원 배열 생성 
    - 단위행렬이란 주 대각선의 원소가 1이고 나머지 원소는 0인 행렬

  ```python
  ## np.eye()로 단위행렬을 갖는 배열 생성
  ----------------------------<코드>----------------------------
  
  are1 = np.eye(3)
  are2 = np.eye(5)
  are3 = np.eye(2)
  
  print(are1)
  print(are2)
  print(are3)
  
  ----------------------------<결과>----------------------------
  [[1. 0. 0.]
   [0. 1. 0.]
   [0. 0. 1.]]
   
  [[1. 0. 0. 0. 0.]
   [0. 1. 0. 0. 0.]
   [0. 0. 1. 0. 0.]
   [0. 0. 0. 1. 0.]
   [0. 0. 0. 0. 1.]]
   
  [[1. 0.]
   [0. 1.]]
  ```

- #### 데이터 타입 확인

  - `arr_obj.dtype` 	

    - 배열 객체의 타입을 확인

  - NumPy 데이터 형식

    |   기호    | 의미                                                |
    | :-------: | :-------------------------------------------------- |
    |    'b'    | 불[bool]                                            |
    |    'i'    | 기호가 있는 정수[signed integer]                    |
    |    'u'    | 기호가 없는 정수[unsigned integer]                  |
    |    'f'    | 실수[floating-point]                                |
    |    'c'    | 복소수[complex-floating point]                      |
    |    'M'    | 날짜[datetime]                                      |
    |    'O'    | 파이썬객체[Python objects]                          |
    | 'S' / 'a' | 바이트 문자열[byte string]                          |
    |    'U'    | 유니코드[Unicode] (뒤의 붙는 숫자는 최대 문자의 수) |



- #### 배열의 데이터 타입 변환

  - `tran_arr = arr_obj.astype(dtype)`
    - arr_obj의 배열을 dtype 타입으로 변환하고, 변환된 배열 객체를 tran_arr에 대입
    - 문자열로 구성된 배열의 모든 원소를 정수나 실수로 변환 또는 정수/실수를 문자열로 변환
    - 정수를 실수로 변환 또는 실수를 정수로 변환

  ```python
  ## 문자열을 원소로 갖는 NumPy 배열을 실수타입으로 변환
  ----------------------------<코드>----------------------------
  
  str_ar1 = np.array(['1.234', '0.123', '5.123', '9', '3'])
  num_ar1 = str_ar1.astype(float)		# 문자열인 원소를 실수로 변환
  print(num_ar1)
  
  print(str_ar1.dtype)
  print(num_ar1.dtype)
  
  ----------------------------<결과>----------------------------
  [1.234 0.123 5.123 9.    3.   ]
  <U5			# 최대 문자수가 5인 유니코드 데이터타입(문자열)
  float64		# 64비트의 실수형
  ```

  ```python
  ## 문자열을 원소로 갖는 numpy 배열을 정수타입으로 변환
  ----------------------------<코드>----------------------------
  
  str_ar2 = np.array(['1', '2', '3', '4'])
  num_ar2 = str_ar2.astype(int)		# 문자열인 원소를 정수로 변환
  print(num_ar2)
  
  print(str_ar2.dtype)
  print(num_ar2.dtype)
  
  ----------------------------<결과>----------------------------
  [1 2 3 4]
  <U1			# 최대문자수가 1인 유니코드 데이터타입(문자열)
  int64		# 64비트의 정수형
  ```

  ```python
  ## 실수를 원소로 갖는 numpy 배열을 정수형으로 변환
  ----------------------------<코드>----------------------------
  
  num_f1 = np.array([10, 21, 3.13, 2.72, 5.84])
  num_i1 = num_f1.astype(int)
  print(num_i1)
  
  print(num_f1.dtype)
  print(num_i1.dtype)
  
  ----------------------------<결과>----------------------------
  [10 21  3  2  5]
  float64
  int64
  ```



- #### 난수 배열 생성

  > random 모듈을 이용하여 임의의 숫자인 난수(random number)를 생성

  - `np.random.rand(d1, d2, ... , dn)`
    - [0,1) 범위의 실수 난수를 원소로 갖는 배열 생성
    - `rand()`에 인자가 없으면 난수 1개를 생성
    - `d1, d2, ... , dn` 은 배열의 크기
  - `np.random.randint([low,] high [,size])`
    - [low, high) 사이의 정수 난수를 원소로 갖는 배열 생성
    - `low`가 생략되면 0으로 간주하고, `size`가 생략되면 1로 간주함
    - `size = (d1, d2, ... , dn)`으로 입력해서 크기를 지정

  ```python
  ## rand()을 이용하여 실수 난수를 원소로 갖는 배열 생성
  ----------------------------<코드>----------------------------
  
  ran_arr1 = np.random.rand()
  ran_arr2 = np.random.rand(3)
  ran_arr3 = np.random.rand(2,3)
  ran_arr4 = np.random.rand(2,3,4)
  
  print(ran_arr1)
  print()
  print(ran_arr2)
  print()
  print(ran_arr3)
  print()
  print(ran_arr4)
  
  ----------------------------<결과>----------------------------
  0.44824395969215336						# 실수 1개 
  	
  [0.15747727 0.6874496  0.29830424]		# 원소가 3개인 1차원 배열
  
  [[0.81029893 0.66345291 0.37985234]
   [0.47439082 0.71376514 0.25358668]]	# 2x3인 2차원 배열
  
  [[[0.25357439 0.26794274 0.04588856 0.99637639]
    [0.87959056 0.45172073 0.01973225 0.02945277]
    [0.4701212  0.00228858 0.40887994 0.76236931]]
  
   [[0.2796868  0.01650915 0.19587565 0.47992455]
    [0.38996545 0.64219117 0.34302551 0.55801736]		# 2x3x4인 3차원 배열
    [0.842475   0.43343198 0.1603189  0.62443745]]]
  ```

  ```python
  ## randint()을 이용해서 정수 난수를 원소로 갖는 배열 생성
  ----------------------------<코드>----------------------------
  
  rani_arr1 = np.random.randint(6)	# 0부터 5까지의 난수 1개 
  rani_arr2 = np.random.randint(1,10) # 1부터 9까지의 난수 1개
  rani_arr3 = np.random.randint(1,30, size=(5))	# 1~29 5개의 난수를 원소로 갖는 1차원 배열
  rani_arr4 = np.random.randint(1,30, size=(3,4))	# 1~29 난수를 원소로 갖는 3x4배열 생성
  rani_arr5 = np.random.randint(20, size=(2,3,4))	# 0~19 난수를 원소로 갖는 2x3x4배열 생성
  
  print(rani_arr1)
  print(rani_arr2)
  print(rani_arr3)
  print(rani_arr4)
  print(rani_arr5)
  
  ----------------------------<결과>----------------------------
  0
  9
  
  [ 5  7 22 27 24]
  
  [[13 28 12 18]
   [21 16 21  4]
   [21 26 23 10]]
   
  [[[12 16 18 12]
    [10  4 12 13]
    [13  6 11 13]]
  
   [[ 0  3 11  4]
    [ 3  2  5 15]
    [ 9  4 16  7]]]
  ```



- #### 배열의 기본 연산

  > __배열의 형태가 같은__ 배열끼리는 `+`, `-`, `*`, `**`, `/` , 비교 연산까지 가능
  >
  > 배열이 형태가 같다는 것은 `arr_obj.shape`결과가 같아야 함(행과 열의 개수가 일치해야함)

  | 연산     | 의미                        | 사용 예                    |
  | -------- | --------------------------- | -------------------------- |
  | +        | 같은 위치의 원소들의 합     | arr1 + arr2                |
  | -        | 같은 위치의 원소들의 차     | arr1 - arr2                |
  | * (상수) | 각 원소에 (상수)를 곱함     | arr1 * 2                   |
  | *        | 같은 위치의 원소들의 곱     | arr1 * arr2                |
  | **       | 각 원소에 거듭제곱          | arr1 ** 3                  |
  | /        | 같은 위치의 원소끼리 나눔   | arr2 / arr1                |
  | 비교연산 | 같은위치의 원소들끼리  비교 | arr1 > 20 <br />arr1<=arr2 |

  ```python
  ## 배열의 기본 연산
  ----------------------------<코드>----------------------------
  
  arr1 = np.array([[1,2,3], [4,5,6]])		# 2x3인 배열
  arr2 = np.array([[2,4,3], [2,10,12]])		# 2x3인 배열
  
  # 더하기 연산
  arr_res1 = arr1 + arr2
  print("===== 배열의 더하기 연산 =====")
  print(arr_res1)
  
  # 빼기 연산
  arr_res2 = arr2 - arr1
  print("===== 배열의 빼기 연산 =====")
  print(arr_res2)
  
  # 상수배 연산
  arr_res3 = arr1 * 5
  print("===== 배열의 상수배 연산 =====")
  print(arr_res3)
  
  # 곱하기 연산
  arr_res4 = arr1 * arr2
  print("===== 배열의 곱하기 연산 =====")
  print(arr_res4)
  
  # 거듭제곱 연산
  arr_res5 = arr1 ** 2
  print("===== 배열의 거듭제곱 연산 =====")
  print(arr_res5)
  
  # 나누기 연산
  arr_res6 = arr2 / arr1
  print("===== 배열의 나누기 연산 =====")
  print(arr_res6)
  
  # 비교 연산
  arr_res7 = arr2 <= arr1
  arr_res8 = arr2 > 3
  print("===== 배열의 비교 연산 =====")
  print(arr_res7)
  print()
  print(arr_res8)
  
  ----------------------------<결과>----------------------------
  ===== 배열의 더하기 연산 =====
  [[ 3  6  6]
   [ 6 15 18]]
  ===== 배열의 빼기 연산 =====
  [[ 1  2  0]
   [-2  5  6]]
  ===== 배열의 상수배 연산 =====
  [[ 5 10 15]
   [20 25 30]]
  ===== 배열의 곱하기 연산 =====
  [[ 2  8  9]
   [ 8 50 72]]
  ===== 배열의 거듭제곱 연산 =====
  [[ 1  4  9]
   [16 25 36]]
  ===== 배열의 나누기 연산 =====
  [[2.  2.  1. ]
   [0.5 2.  2. ]]
  ===== 배열의 비교 연산 =====
  [[False False  True]
   [ True False False]]
  
  [[False  True False]
   [False  True  True]]
  ```

- #### 통계 연산

  > NumPy에서는 배열의 합, 평균, 표준편차, 분산, 최댓값, 최솟값, 누적 합, 누적 곱 등 
  > 통계에 많이 사용되는 연산을 메서드를 이용하여 할 수 있음

  |  메서드   |            의미             |      사용 예      |
  | :-------: | :-------------------------: | :---------------: |
  |   sum()   |    배열 원소의 합을 구함    |   arr_obj.sum()   |
  |  mean()   |   배열 원소의 평균을 구함   |  arr_obj.mean()   |
  |   std()   | 배열 원소의 표준편차를 구함 |   arr_obj.std()   |
  |   var()   |   배열 원소의 분산을 구함   |   arr_obj.var()   |
  |   min()   | 배열 원소 중 최솟값을 구함  |   arr_obj.min()   |
  |   max()   | 배열 원소 중 최댓값을 구함  |   arr_obj.max()   |
  | cumsum()  |  배열 원소의 누적합을 구함  | arr_obj.cumsum()  |
  | cumprod() |  배열 원소의 누적곱을 구함  | arr_obj.cumprod() |

  ```python
  ## 배열의 통계 연산
  ----------------------------<코드>----------------------------
  
  arr3 = np.random.randint(1,3, size =(2,3))	# 1부터 3까지의 정수 난수를 원소로하는 2x3배열
  print("arr3 배열")
  print(arr3)
  
  # 합 구하기
  res1 = arr3.sum()
  print("===== 배열의 합 =====")
  print(res1)
  
  # 평균 구하기
  res2 = arr3.mean()
  print("===== 배열의 평균 =====")
  print(res2)
  
  # 표준편차 구하기
  res3 = arr3.std()
  print("===== 배열의 표준편차 =====")
  print(res3)
  
  # 분산 구하기
  res4 = arr3.var()
  print("===== 배열의 분산 =====")
  print(res4)
  
  # 최댓값 구하기
  res5 = arr3.max()
  print("===== 배열의 최댓값 =====")
  print(res5)
  
  # 최솟값 구하기
  res6 = arr3.min()
  print("===== 배열의 최솟값 =====")
  print(res6)
  
  # 누적합 구하기
  arr_res7 = arr3.cumsum()
  print("===== 배열의 누적합 =====")
  print(arr_res7)
  
  # 누적곱 구하기
  arr_res8 = arr3.cumprod()
  print("===== 배열의 누적곱 =====")
  print(arr_res8)
  
  ----------------------------<결과>----------------------------
  arr3 배열
  [[1 2 1]
   [2 1 1]]
  ===== 배열의 합 =====
  8
  ===== 배열의 평균 =====
  1.3333333333333333
  ===== 배열의 표준편차 =====
  0.4714045207910317
  ===== 배열의 분산 =====
  0.22222222222222224
  ===== 배열의 최댓값 =====
  2
  ===== 배열의 최솟값 =====
  1
  ===== 배열의 누적합 =====
  [1 3 4 6 7 8]
  ===== 배열의 누적곱 =====
  [1 2 2 4 4 4]
  ```



- #### 행렬 연산

  > NumPy는 배열의 연산뿐 아니라 선형대수를 위한 행렬(2차원 배열)연산도 가능
  >
  > 행렬 곱, 전치 행렬, 역행렬, 행렬식 구하기

  |         행렬 연산          |              사용 예               |
  | :------------------------: | :--------------------------------: |
  |  행렬 곱(matrix product)   |     A.dot(B) 또는 np.dot(A,B)      |
  | 전치행렬(transpose matrix) | A.transpose() 또는 np.transpose(A) |
  |   역행렬(inverse matrix)   |          np.linalg.inv(A)          |
  |    행렬식(determinant)     |          np.linalg.det(A)          |

  ```python
  ## 행렬 연산 (행렬 연산을 위해 2x2 배열 A, B 생성 후 연산)
  ----------------------------<코드>----------------------------
  
  A = np.array([1,2,2,3]).reshape(2,2)
  B = np.array([3,2,1,2]).reshape(2,2)
  
  # 행렬곱 구하기
  mat_res1 = A.dot(B)		# 또는 np.dot(A,B)
  print("===== 행렬곱 =====")
  print(mat_res1)
  
  # 전치행렬 구하기
  mat_res2 = np.transpose(A)
  mat_res3 = B.transpose()
  print("===== A의 전치행렬 =====")
  print(mat_res2)
  print("===== B의 전치행렬 =====")
  print(mat_res3)
  
  # 역행렬 구하기
  mat_res4 = np.linalg.inv(A)
  mat_res5 = np.linalg.inv(B)
  print("===== A의 역행렬 =====")
  print(mat_res4)
  print("===== B의 역행렬 =====")
  print(mat_res5)
  
  # det(A)/ det(B) 구하기
  res6 = np.linalg.det(A)
  res7 = np.linalg.det(B)
  print("===== det(A) 구하기 =====")
  print(res6)
  print("===== det(B) 구하기 =====")
  print(res7)
  
  ----------------------------<결과>----------------------------
  ===== 행렬곱 =====
  [[ 5  6]
   [ 9 10]]
  ===== A의 전치행렬 =====
  [[1 2]
   [2 3]]
  ===== B의 전치행렬 =====
  [[3 1]
   [2 2]]
  ===== A의 역행렬 =====
  [[-3.  2.]
   [ 2. -1.]]
  ===== B의 역행렬 =====
  [[ 0.5  -0.5 ]
   [-0.25  0.75]]
  ===== det(A) 구하기 =====
  -1.0
  ===== det(B) 구하기 =====
  4.000000000000001
  ```

  

- #### 배열의 인덱싱(Indexing) & 슬라이싱(Slicing)

  > 배열의 위치, 조건, 범위를 지정해서 필요한 원소를 선택하는 작업이 필요
  >
  > 배열에서 선택된 원소의 값을 가져오거나 변경하는 등.

  - #### 인덱싱(Indexing)

    - 배열의 위치나 조건을 지정해서 배열의 원소를 선택하는 것
    - 1차원 배열에서 특정 원소를 선택하기 위해 원소의 위치를 지정
      - `배열명[위치]` 로 해당 원소를 불러오기
      - 배열의 위치(Index)는 0부터 시작
      - `배열명[[위치1, 위치2, ... , 위치n]]`으로 해당 위치의 원소들을 여러 개 가져오기 가능
    - 2차원 배열에서 특정 원소의 위치 지정 
      - `배열명[행_위치],[열_위치]`로 해당 원소 불러오기
      - `열_위치` 가 생략된다면 지정한 행 전체가 선택됨
      - `배열명[행_위치1, ... , 행_위치n],[열_위치1, ... , 열_위치n]`으로 여러 개의 원소 선택 
    - 조건을 지정하여 만족하는 원소 선택 가능
      - `배열명[조건]` 으로 조건을 만족하는 원소들을 선택

    ```python
    ## 인덱싱 실습
    ----------------------------<코드>----------------------------
    
    a1 = np.array([0, 10, 20, 30, 40, 50])		# 1차원 배열 생성
    
    print('a1[0] = ', a1[0])
    print('a1[4] = ', a1[4])		# 배열에서 인덱스가 4에 해당하는 원소 출력
    
    a1[5] = 70					# 6번째 원소(50)의 값을 70으로 변경
    print("modified a1")
    print(a1)
    
    print('a1[[1,3,4]] = ', a1[[1,3,4]])	# 인덱스가 1, 3, 4인 원소들을 모두 출력
    
    a2 = np.arange(10,100,10).reshape(3,3)	# 2차원 배열 생성
    print('a2')
    print(a2)
    
    print('a2[0,2] = ', a2[0,2])	# (0,2) 위치의 원소 출력
    
    a2[2,2] = 95			# (2,2)위치의 원소 값을 95로 변경
    print('modified a2')
    print(a2)
    
    print('a2[1] = ', a2[1])	# 두번째 행 전체 출력
    
    a2[1] = np.array([45,55,65])	# 두번째 행 전체의 값을 변경
    print('modified a2')
    print(a2)
    
    a2[2] = [47,57,67]		# 세번쨰 행 전체의 값을 변경
    print('modified a2')
    print(a2)
    
    print('a2의 (0,0), (2,1) = ', a2[[0,2],[0,1]]) 	# (0,0), (2,1) 원소 동시에 출력
    
    a = np.array([1,2,3,4,5,6])		# 새로운 1차원 배열 생성
    print("3보다 큰 원소 : ", a[a>3])	# 조건을 만족하는 원소 출력
    
    ----------------------------<결과>----------------------------
    a1[0] =  0
    a1[4] =  40
    modified a1
    [ 0 10 20 30 40 70]
    a1[[1,3,4]] =  [10 30 40]
    a2
    [[10 20 30]
     [40 50 60]
     [70 80 90]]
    a2[0,2] =  30
    modified a2
    [[10 20 30]
     [40 50 60]
     [70 80 95]]
    a2[1] =  [40 50 60]
    modified a2
    [[10 20 30]
     [45 55 65]
     [70 80 95]]
    modified a2
    [[10 20 30]
     [45 55 65]
     [47 57 67]]
    a2의 (0,0), (2,1) =  [10 57]
    3보다 큰 원소 :  [4 5 6]
    ```

  - #### 슬라이싱(Slicing)

    - 범위를 지정하여 배열의 일부분을 선택
    - 1차원 배열
      - `배열[시작_위치:끝_위치]` 
      - return되는 원소의 범위는 시작위치 ~ 끝위치-1 
      - 시작위치를 생략하면 0이 됨
      - 끝위치를 생략하면 배열의 길이(배열의 끝)이 됨
    - 2차원 배열
      - `배열[행시작위치:행끝위치, 열시작위치:열끝위치]`
      - 행의 범위는 행시작위치~행끝위치-1, 열의 범위는 열시작위치~열끝위치-1
      - 행시작위치나 열시작위치를 생략하면 0이됨
      - 행끝위치나 열끝위치를 생략하면 각각 행의 끝까지, 열의 끝가지로 됨
      - `배열[행위치][열시작위치:열끝위치]` 로 행은 정해져있고 열로 범위를 선택 가능

    ```python
    ## 슬라이싱 실습
    ----------------------------<코드>----------------------------
    
    b1 = np.array([0,10,20,30,40,50])
    
    print('b1[1:4] : ', b1[1:4])	# b1의 인덱스가 1~3까지의 원소 출력
    print('b1[:3] : ', b1[:3])		# b1의 인덱스가 0~2까지의 원소 출력
    print('b1[2:] : ', b1[2:])		# b1의 인덱스가 2~5까지의 원소 출력
    
    b1[2:5] = np.array([25, 35, 45])	# 범위 지정해서 원소의 값 변경
    print('modified b1')
    print(b1)
    
    b1[3:6] = 60		# 범위의 원소들을 하나의 값으로 변경(모두 60으로 변경)
    print('modified b1')
    print(b1)
    
    b2 = np.arange(10,100,10).reshape(3,3)	
    print('b2')
    print(b2)
    
    print('b2[1:3, 1:3] : ', b2[1:3, 1:3])	# 행, 열이 1~2 인덱스인 범위의 원소 출력
    print('b2[:3, 1:] :' , b2[:3, 1:])	# 0~2의 행, 1~2까지의 열의 원소 출력
    
    print('b2[1][0:2] : ',b2[1][0:2] ) # 1행에서 0~1열의 원소 출력
    
    b2[0:2, 1:3] = np.array([[25,35],[55,65]])	# 범위 지정해서 원소 값 변경
    print('modified b2')
    print(b2)
    
    ----------------------------<결과>----------------------------
    b1[1:4] :  [10 20 30]
    b1[:3] :  [ 0 10 20]
    b1[2:] :  [20 30 40 50]
    modified b1
    [ 0 10 25 35 45 50]
    modified b1
    [ 0 10 25 60 60 60]
    b2
    [[10 20 30]
     [40 50 60]
     [70 80 90]]
    b2[1:3, 1:3] :  [[50 60]
     [80 90]]
    b2[:3, 1:] :  [[20 30]
     [50 60]
     [80 90]]
    b2[1][0:2] :  [40 50]
    modified b2
    [[10 25 35]
     [40 55 65]
     [70 80 90]]
    ```

    

## 11.2 Pandas 구조적 데이터 처리 & 표현

- #### 구조적 데이터 생성

  - `import pandas as pd` : pandas도 import해서 불러옴

    - 별명 `pd`를 붙여서 `pandas`대신 사용 가능

  - `s = pd.Series(seq_data)` 

    - `Series()` 인자로는 시퀀스 데이터(리스트, 튜플, 딕셔너리 등) 사용
    - `seq_data`에 순서를 표시하는 __라벨이 자동으로 부여됨__
    - 세로축 라벨을 __index__라고 하고, 입력한 `seq_data` 데이터를 __value__라고 함
    - pandas의 경우 __원소의 data type은 다를 수 있음__
    - `np.nan`을 이용하여 데이터가 없다고 표현 (비어있는 데이터를 표시)
      - 데이터를 위한 자리(index)는 있지만 실제 값(value)는 없는 상태를 의미

  - ##### Series 구조

  ```python
  ----------------------------<코드>----------------------------
  
  import pandas as pd			# 처음에는 import해주면 전체 코드 내에서 사용 가능
  
  s1 = pd.Series([10, 20, 30, 40, 50])
  print(s1)
  
  ----------------------------<결과>----------------------------
  0    10
  1    20
  2    30
  3    40
  4    50				# 왼쪽 세로줄은 index, 오른쪽 세로줄은 value
  dtype: int64		# data type은 64비트의 int형
  ```

   - ##### index와 values를 분리해서 가져오기 가능

      - `s1.index` : s1의 index만 가져옴
        	- `RangeIndex(start, stop, step)` 형식으로 출력
        	- index의 범위는 `start` ~ `stop - 1` 이며 간격은 `step`만큼 증가
      - `s1.values` : s1의 values만 가져옴
         - NumPy의 배열 형식과 같음

  ```python
  ## index, value를 따로 출력하기
  ----------------------------<코드>----------------------------
  
  print(s1.index)
  print(s1.values)
  
  ----------------------------<결과>----------------------------
  RangeIndex(start=0, stop=5, step=1)
  [10 20 30 40 50]
  ```

  ```python
  ## 문자와 숫자가 혼합된 리스트로 데이터 생성
  ----------------------------<코드>----------------------------
  
  s2 = pd.Series(['a', 'b', 'c', 1, 2, 3])
  print(s2)
  
  ----------------------------<결과>----------------------------
  0    a
  1    b
  2    c
  3    1
  4    2
  5    3
  dtype: object		# data type은 문자와 숫자가 혼합되어 있으므로 객체(object)형
  ```

  ```python
  ## 비어있는 데이터가 포함된 리스트를 구조적 데이터로 생성
  ----------------------------<코드>----------------------------
  
  import numpy as np 		# np.nan을 사용하기 위해 numpy import
  
  s3 = pd.Series([np.nan, 10, 30])
  print(s3)
  
  ----------------------------<결과>----------------------------
  0     NaN			# NaN은 데이터가 없다는 것을 의미
  1    10.0
  2    30.0
  dtype: float64
  ```

  - ##### index를 추가해서 Series 데이터 생성

    - `s = pd.Series(seq_data, index = index_seq)`
      - 인자로 index를 명시적으로 입력시 자동 생성되었던 index 대신에 `index_seq`가 들어가게됨
      - `index_seq`도 `seq_data`와 마찬가지로 리스트, 튜플타입의 데이터 사용 가능
      - __seq_data의 항목개수와 index_seq의 항목 개수는 같아야함__

  ```python
  ## 어느 가게의 날짜별 판매량을 Series 데이터로 생성
  ----------------------------<코드>----------------------------
  
  index_date = ['2018-10-07', '2018-10-08', '2018-10-09', '2018-10-10']
  s4 = pd.Series([200, 195, None, 205], index = index_date)
  print(s4)
  
  ----------------------------<결과>----------------------------
  2018-10-07    200.0
  2018-10-08    195.0
  2018-10-09      NaN		# 판매량 데이터가 없어서 NaN으로 처리
  2018-10-10    205.0
  dtype: float64
  ```

  - ##### 딕셔너리(Dictionary) 데이터로 Series 데이터 생성

    - `seq_data`에 딕셔너리를 이용하면 index와 value를 함께 입력 가능
    - `s = pd.Series(dict_data)`
      - 딕셔너리 데이터의 key는 Series의 index, 딕셔너리 데이터의 value는 Series의 value가 됨

  ```python
  ## 딕셔너리 데이터를 이용해서 Series 데이터 생성
  ----------------------------<코드>----------------------------
  
  s5 = pd.Series({'국어':100, '영어':95, '수학':100})	# seq_data로 dictionary 데이터 이용
  print(s5)
  
  ----------------------------<결과>----------------------------
  국어    100			# 딕셔너리의 키가 index, 값이 value으로 Series 데이터 생성
  영어     95
  수학    100
  dtype: int64
  ```

- #### 날짜 자동 생성 

  - ##### 날짜 데이터 생성

    - `pd.date_range(start='시작날짜', end='끝날짜', periods=생성기간, freq = 'D')`
    - `start` :시작 날짜, `end` :끝 날짜, `periods` :날짜 데이터 생성 기간, `freq`: 날짜 데이터 생성 주기
    - `start`는 반드시 있어야하고, `end`나 `periods`는 둘 중 하나 생략 가능
    - `freq`를 입력하지 않으면 `'D'`옵션이 default로 설정 되어 있음. (날짜 기준으로 하루씩 증가)
    - `freq` 옵션으로는 `'W'`(일주일 주기), `'M'`(월 주기), `'QS'`(분기 주기), `'AS'`(연도 주기),
      `'H'`(시간 주기) , `'BH'`(업무시간 주기), `'min'`/`'T'`(분 주기), `'S'`(초 주기) 등이 있음
    - 생성된 날짜 데이터 형식은 `yyyy-mm-dd`
    - `start =`는 생략 가능,  `'시작날짜'`만 지정해도 됨 

  ```python
  ## 시작 날짜와 끝 날짜를 지정해서 날짜 데이터 생성
  ----------------------------<코드>----------------------------
  
  pd.date_range(start = '2019-01-01', end='2019-01-07')	# 하루씩 증가하는 날짜 데이터 생성
  pd.date_range(start = '01-01-2019', end='01/07/2019')	
  
  # 날짜 입력시 연도 순서(연-월-일 / 월-일-년)
  # 날짜 구분자( , . / ) 사용 가능
  
  ----------------------------<결과>----------------------------
  DatetimeIndex(['2019-01-01', '2019-01-02', '2019-01-03', '2019-01-04',
                 '2019-01-05', '2019-01-06', '2019-01-07'],
                dtype='datetime64[ns]', freq='D')
                
  ## end를 생략하고 periods를 지정해서 날짜 데이터 생성
  ----------------------------<코드>----------------------------
  
  pd.date_range('2019-01-01', periods=7)	# 2019/01/01부터 시작해서 7개의 데이터
  
  ----------------------------<결과>----------------------------
  DatetimeIndex(['2019-01-01', '2019-01-02', '2019-01-03', '2019-01-04',
                 '2019-01-05', '2019-01-06', '2019-01-07'],
                dtype='datetime64[ns]', freq='D')
                
  ## 2일씩 증가하는 날짜 데이터 4개 생성
  ----------------------------<코드>----------------------------
  
  pd.date_range('2019-01-01', periods=4, freq = '2D')
  
  ----------------------------<결과>----------------------------
  DatetimeIndex(['2019-01-01', '2019-01-03', '2019-01-05', '2019-01-07'], dtype='datetime64[ns]', freq='2D')
  
  ## 달력 요일 기준으로 일주일씩 증가하는 날짜 데이터 4개 생성
  ----------------------------<코드>----------------------------
  
  pd.date_range(start='2019-01-01', periods=4, freq='W')
  
  ----------------------------<결과>----------------------------
  DatetimeIndex(['2019-01-06', '2019-01-13', '2019-01-20', '2019-01-27'], dtype='datetime64[ns]', freq='W-SUN')
  
  ## 업무일 기준으로 2개월 월말 주기로 12개의 날짜 생성
  ## 업무일 기준이므로 월-금 주중만 표시됨
  ----------------------------<코드>----------------------------
  
  pd.date_range(start='2019-01-01', periods=12, freq='2BM')
  
  ----------------------------<결과>----------------------------
  DatetimeIndex(['2019-01-31', '2019-03-29', '2019-05-31', '2019-07-31',
                 '2019-09-30', '2019-11-29', '2020-01-31', '2020-03-31',
                 '2020-05-29', '2020-07-31', '2020-09-30', '2020-11-30'],
                dtype='datetime64[ns]', freq='2BM')
  
  ## 분기 시작일을 기준으로 4개 날짜를 생성
  ----------------------------<코드>----------------------------
  
  pd.date_range('2019-01-01', periods=4, freq='QS')
  
  ----------------------------<결과>----------------------------
  DatetimeIndex(['2019-01-01', '2019-04-01', '2019-07-01', '2019-10-01'], dtype='datetime64[ns]', freq='QS-JAN')
  
  ## 연도 첫날을 기준으로 1년 주기로 3개의 날짜 생성
  ----------------------------<코드>----------------------------
  
  pd.date_range(start='2019-01-01', periods=3, freq='AS')
  
  ----------------------------<결과>----------------------------
  DatetimeIndex(['2019-01-01', '2020-01-01', '2021-01-01'], dtype='datetime64[ns]', freq='AS-JAN')
  
  ## 1시간 주기로 10개의 시간 생성
  ----------------------------<코드>----------------------------
  
  pd.date_range(start='2019-01-01 08:00', periods=10, freq='H')
  
  ----------------------------<결과>----------------------------
  DatetimeIndex(['2019-01-01 08:00:00', '2019-01-01 09:00:00',
                 '2019-01-01 10:00:00', '2019-01-01 11:00:00',
                 '2019-01-01 12:00:00', '2019-01-01 13:00:00',
                 '2019-01-01 14:00:00', '2019-01-01 15:00:00',
                 '2019-01-01 16:00:00', '2019-01-01 17:00:00'],
                dtype='datetime64[ns]', freq='H')
  
  ## 업무시간을 기준으로 1시간 주기로 10개의 시간 생성
  ## 업무시간은 09:00 - 16:00
  ----------------------------<코드>----------------------------
  
  pd.date_range(start='2019-01-01 10:00', periods=10, freq='BH')
  
  ----------------------------<결과>----------------------------
  DatetimeIndex(['2019-01-01 10:00:00', '2019-01-01 11:00:00',
                 '2019-01-01 12:00:00', '2019-01-01 13:00:00',
                 '2019-01-01 14:00:00', '2019-01-01 15:00:00',
                 '2019-01-01 16:00:00', '2019-01-02 09:00:00',
                 '2019-01-02 10:00:00', '2019-01-02 11:00:00'],
                dtype='datetime64[ns]', freq='BH')
  
  ## 30분 단위로 4개의 시간을 생성
  ## 분 단위의 freq는 'min', 'T' 모두 사용 가능
  ----------------------------<코드>----------------------------
  
  pd.date_range(start='2019-01-01 10:00', periods=4, freq='30T')
  
  ----------------------------<결과>----------------------------
  DatetimeIndex(['2019-01-01 10:00:00', '2019-01-01 10:30:00',
                 '2019-01-01 11:00:00', '2019-01-01 11:30:00'],
                dtype='datetime64[ns]', freq='30T')
  
  ## 10초 단위로 증가하면서 4개의 시간 생성
  ----------------------------<코드>----------------------------
  
  pd.date_range('2019-01-01 10:00', periods=4, freq='10S')
  
  ----------------------------<결과>----------------------------
  DatetimeIndex(['2019-01-01 10:00:00', '2019-01-01 10:00:10',
                 '2019-01-01 10:00:20', '2019-01-01 10:00:30'],
                dtype='datetime64[ns]', freq='10S')
  ```

  ```python
  ## date_range()를 이용하여 Series의 index를 지정
  ## 특정 날짜로부터 5일간의 판매량 표시
  ----------------------------<코드>----------------------------
  
  index_date = pd.date_range(start = '2019-03-01', periods = 5, freq='D')
  pd.Series([51,62,55,49,58], index = index_date)
  
  ----------------------------<결과>----------------------------
  2019-03-01    51
  2019-03-02    62
  2019-03-03    55
  2019-03-04    49
  2019-03-05    58
  Freq: D, dtype: int64
  ```

- #### DataFrame을 활용하여 데이터 생성

  > pandas는 표(Table)와 같이 2차원 데이터 처리를 위해 DataFrame을 제공
  >
  > DataFrame은 자료(Data)를 담는 틀(Frame)
  >
  > DataFrame을 이용해서 2차원 데이터를 생성하고 처리할 수 있음

  - ##### 데이터 생성 

    - `df = pd.DataFrame(data[, index = index_data, columns = columns_data])`
    - `data`에는 리스트와 형태가 유사한 데이터타입 모두 사용 가능
      - 리스트, 딕셔너리, NumPy 배열, Series, DataFrame 타입 데이터 등
    - 세로출 라벨을 __index__라고 하고, 가로축 라벨을 __columns__라고 함
      - index와 columns에는 1차원 배열과 유사한 데이터 타입(리스트, NumPy배열, Series 등) 가능
      - __data의 행 개수와 index요소의 개수, data의 열 개수와 columns 요소의 개수가 일치해야함__
      - index와 columns는 선택사항이므로 입력하지 않으면 0부터 시작하는 숫자가 생성되어 채워짐
      - index, columns 제외한 부분이 values
    - `df.index` / `df.columns` / `df.values` 로 각각 index, columns, values를 따로 구할 수 있음
      - index는 Series와 같이 index range로 출력이 됨(시작, 끝, step)
      - column은 리스트 형식으로 출력되며, 데이터 타입도 출력

  ```python
  ## 리스트를 이용해서 DataFrame 데이터 생성
  ----------------------------<코드>----------------------------
  
  pd.DataFrame([[1,2,3], [4,5,6], [7,8,9]])
  
  ----------------------------<결과>----------------------------
  	0	1	2
  0	1	2	3		# index와 columns를 따로 지정하지 않으면 0부터 숫자 자동 생성
  1	4	5	6
  2	7	8	9
  ```

  ```python
  ## NumPy 배열 데이터를 이용해서 DataFrame 데이터 생성
  ----------------------------<코드>----------------------------
  
  data_list = np.array([[10, 20, 30], [40, 50, 60], [70, 80, 90]])
  pd.DataFrame(data_list)
  
  ----------------------------<결과>----------------------------
  	0	1	2
  0	10	20	30
  1	40	50	60
  2	70	80	90
  ```

  ```python
  ## index와 columns를 지정해서 DataFrame 데이터 생성
  ----------------------------<코드>----------------------------
  
  data = np.array([[1,2,3], [4,5,6], [7,8,9], [10,11,12]])
  index_data = pd.date_range('2019-09-01', periods = 4)
  columns_data = ['A', 'B', 'C']
  pd.DataFrame(data, index = index_data, columns = columns_data)
  
  ----------------------------<결과>----------------------------
  			A	B	C
  2019-09-01	1	2	3
  2019-09-02	4	5	6
  2019-09-03	7	8	9
  2019-09-04	10	11	12
  ```

  ```python
  ## dictionary 데이터를 이용해서 DataFrame 데이터 생성
  ## dictionary의 key는 column으로, value는 value로 생성
  ----------------------------<코드>----------------------------
  
  table_data = {'연도': [2015, 2016, 2016, 2017, 2017],
  			  '지사': ['한국', '한국', '미국', '한국', '미국'],
  			  '고객 수': [200, 250, 450, 300, 500]}
  
  pd.DataFrame(table_data)
  
  ----------------------------<결과>----------------------------
  	연도	   지사  고객 수
  0	2015	한국	200
  1	2016	한국	250
  2	2016	미국	450
  3	2017	한국	300
  4	2017	미국	500
  ```

  ```python
  ## 위와 똑같은 데이터를 이용
  ## column을 정렬하기 위해(한글은 가나다순, 영어는 알파벳순) columns = []으로 순서 지정 가능
  ----------------------------<코드>----------------------------
  
  df = pd.DataFrame(table_data, columns=['고객 수', '지사', '연도'])
  df
  
  ----------------------------<결과>----------------------------
  ```

  ```python
  ## index, columns, values 각각 구하기
  ----------------------------<코드>----------------------------
  
  print(df.index)
  print(df.columns)
  print(df.values)
  
  ----------------------------<결과>----------------------------
  RangeIndex(start=0, stop=5, step=1)
  Index(['고객 수', '지사', '연도'], dtype='object')
  [[200 '한국' 2015]
   [250 '한국' 2016]
   [450 '미국' 2016]
   [300 '한국' 2017]
   [500 '미국' 2017]]
  ```

- #### 데이터 연산

  - pandas의 Series()와 DataFrame()으로 생성한 데이터끼리 사칙 연산 / 통계 연산 가능
  - 항목의 개수가 달라도 연산 가능한 항목끼리만 연산하고 그밖의 항목은 NaN으로 표시
  - 통계분석을 위한 다양한 메서드가 있어 총합, 평균, 표준편차 등을 쉽게 구할 수 있음
    - `mean()` : 평균 구하기
    - `sum()` : 합구하기
    - `std()` : 표준편차 구하기
    - `var()` : 분산 구하기
    - `min()` / `max()` : 최소 / 최대 구하기
    - `cumsum()` / `cumprod()` : 누적합 / 누적곱 구하기
      - __인자로 `axis=0`/ `axis=1` 설정 가능.__
      - __ `axis`가 0이면 열별로 연산 수행, 1이면 행별로 연산 수행__
    - `discribe()` : 평균, 표준편차, 최솟값, 최댓값 등 한번에 table형식으로 출력

  ```python
  ## Series 데이터의 연산
  ----------------------------<코드>----------------------------
  
  s1 = pd.Series([1,2,3,4,5])
  s2 = pd.Series([10,20,30,40,50])
  
  print('+연산 : ', s1 + s2)
  print('-연산 : ', s1 - s2)
  print('*연산 : ', s1 * s2)
  print('/연산 : ', s2 / s1)
  
  ----------------------------<결과>----------------------------
  +연산 : 
  0    11
  1    22
  2    33
  3    44
  4    55
  dtype: int64
  
  -연산 : 
  0    -9
  1   -18
  2   -27
  3   -36
  4   -45
  dtype: int64
  
  *연산 : 
  0     10
  1     40
  2     90
  3    160
  4    250
  dtype: int64
  
  /연산 :  
  0    10.0
  1    10.0
  2    10.0
  3    10.0
  4    10.0
  dtype: float64
  ```

  ```python
  ## 데이터 크기가 다른 두 Series 데이터의 연산
  ----------------------------<코드>----------------------------
  
  s3 = pd.Series([1,2,3,4])
  s4 = pd.Series([10,20,30,40,50])
  
  print('+연산 : ', s3 + s4)
  print('-연산 : ', s3 - s4)
  print('*연산 : ', s3 * s4)
  print('/연산 : ', s4 / s3)
  
  ----------------------------<결과>----------------------------
  +연산 :  
  0    11.0
  1    22.0
  2    33.0
  3    44.0
  4     NaN			# 연산이 불가능한 데이터는 NaN으로 표시
  dtype: float64
  
  -연산 :  
  0    -9.0
  1   -18.0
  2   -27.0
  3   -36.0
  4     NaN
  dtype: float64
  
  *연산 :  
  0     10.0
  1     40.0
  2     90.0
  3    160.0
  4      NaN
  dtype: float64
  
  /연산 :  
  0    10.0
  1    10.0
  2    10.0
  3    10.0
  4     NaN
  dtype: float64
  ```

  ```python
  ## DataFrame 데이터끼리의 연산(데이터 길이가 다름)
  ----------------------------<코드>----------------------------
  
  table_data1 = {'A':[1,2,3,4,5],
  			   'B':[10,20,30,40,50],
  			   'C':[100,200,300,400,500]}
  table_data2 = {'A':[6,7,8],
  			   'B':[60,70,80],
  			   'C':[600,700,800]}
  
  df1 = pd.DataFrame(table_data1)
  df2 = pd.DataFrame(table_data2)
  
  print('+연산 : ', df1 + df2)
  print('-연산 : ', df1 - df2)
  print('*연산 : ', df1 * df2)
  print('/연산 : ', df2 / df1)
  
  ----------------------------<결과>----------------------------
  +연산 :        
  	A      B       C
  0   7.0   70.0   700.0
  1   9.0   90.0   900.0
  2  11.0  110.0  1100.0
  3   NaN    NaN     NaN		# DataFrame도 마찬가지로 연산 불가능한 항목은 NaN으로 표시
  4   NaN    NaN     NaN
  
  -연산 :   
  	A     B      C
  0 -5.0 -50.0 -500.0
  1 -5.0 -50.0 -500.0
  2 -5.0 -50.0 -500.0
  3  NaN   NaN    NaN
  4  NaN   NaN    NaN
  
  *연산 :      
  	A       B         C
  0   6.0   600.0   60000.0
  1  14.0  1400.0  140000.0
  2  24.0  2400.0  240000.0
  3   NaN     NaN       NaN
  4   NaN     NaN       NaN
  
  /연산 :         
  		A         B         C
  0  6.000000  6.000000  6.000000
  1  3.500000  3.500000  3.500000
  2  2.666667  2.666667  2.666667
  3       NaN       NaN       NaN
  4       NaN       NaN       NaN
  ```

  ```python
  ## 메서드를 이용해 통계 분성 방법
  ## 2012년부터 2016년까지 우리나라의 계절별 강수량(단위mm)
  ----------------------------<코드>----------------------------
  
  table_data3 = {'봄': [256.5, 264.3, 215.9, 223.2, 312.8],
  			   '여름': [770.6, 567.5, 599.8, 387.1, 446.2],
  			   '가을': [363.5, 231.2, 293.1, 247.7, 381.6],
  			   '겨울': [139.3, 59.9, 76.9, 109.1, 108.1]}
  columns_list = ['봄', '여름', '가을', '겨울']
  index_list = ['2012', '2013', '2014', '2015', '2016']
  
  df3 = pd.DataFrame(table_data3, columns = columns_list, index = index_list)
  
  print("mean()[계절별] ", df3.mean())
  print('mean()[연도별]', df3.mean(axis=1))
  print('std()[계절별]', df3.std())
  print('std()[연도별]', df3.std(axis=1))
  
  ----------------------------<결과>----------------------------
  mean()[계절별]  
  봄     254.54
  여름    554.24
  가을    303.42
  겨울     98.66
  dtype: float64
  
  mean()[연도별] 
  2012    382.475
  2013    280.725
  2014    296.425
  2015    241.775
  2016    312.175
  dtype: float64
  
  std()[계절별] 
  봄      38.628267
  여름    148.888895
  가을     67.358496
  겨울     30.925523
  dtype: float64
  
  std()[연도별] 
  2012    274.472128
  2013    211.128782
  2014    221.150739
  2015    114.166760
  2016    146.548658
  dtype: float64
  ```

  ```python
  ## describe()를 이용해서 통계연산들을 한번에 구하기
  ----------------------------<코드>----------------------------
  
  df3.describe()
  
  ----------------------------<결과>----------------------------
  			봄			여름		 가을			 겨울
  count	  5.000000	  5.000000	  5.000000	  5.000000
  mean	254.540000	554.240000	303.420000	 98.660000
  std		 38.628267	148.888895	 67.358496	 30.925523
  min	    215.900000	387.100000	231.200000	 59.900000
  25%	    223.200000	446.200000	247.700000	 76.900000
  50%	    256.500000	567.500000	293.100000	108.100000
  75%		264.300000	599.800000	363.500000	109.100000
  max		312.800000	770.600000	381.600000	139.300000
  ```

  - `df.T`  : DataFrame 데이터인 df를 transpose 시키기
    - `describe()`연산을 행별로 수행하고 싶으면 df를 먼저 transpose시키고, describe()연산 수행
    - 또는, `df.describe().T`로 바로 수행

  ```python
  ## df3을 transpose 시키고 descirbe() 메서드 수행
  ----------------------------<코드>----------------------------
  
  df3_1 = df3.T
  df3_1.describe()
  
  ----------------------------<결과>----------------------------
  
  			2012		2013		2014		2015		2016
  count	  4.000000	  4.000000	  4.000000	  4.00000	  4.000000
  mean	382.475000	280.725000	296.425000	241.77500	312.175000
  std		274.472128	211.128782	221.150739	114.16676	146.548658
  min		139.300000	 59.900000	 76.900000	109.10000	108.100000
  25%		227.200000	188.375000	181.150000	194.67500	261.625000
  50%		310.000000	247.750000	254.500000	235.45000	347.200000
  75%		465.275000	340.100000	369.775000	282.55000	397.750000
  max		770.600000	567.500000	599.800000	387.10000	446.200000
  ```

- #### 데이터 영역 선택

  >  DataFrame의 data를 원본 훼손 없이 원하는 부분만 선택하는 방법

  - `df.head([n])` : 전체 데이터 중 처음 n개의 행의 데이터 return
  - `df.tail([n])` : 전체 데이터 중 끝  n개의 행 데이터 return
    - 인자`n`이 생략되면 default 값으로 5 설정

  ```python
  ## head(), tail()를 이용해서 데이터의 일부분 출력
  ----------------------------<코드>----------------------------
  
  KTX_data = {'경부선 KTX' : [39060, 39896, 42005, 43621, 41702, 41266, 32427],
  			'호남선 KTX' : [7313, 6967, 6873, 6626, 8675, 10622, 9228],
  			'경전선 KTX' : [3627, 4168, 4088, 4424, 4606, 4984, 5570],
  			'전라선 KTX' : [309, 1771, 1954, 2244, 3146, 3945, 5766],
  			'동해선 KTX' : [None, None, None, None, 2395, 3786, 6667]}
  col_list = ['경부선 KTX', '호남선 KTX', '경전선 KTX', '전라선 KTX', '동해선 KTX']
  index_list = ['2011', '2012', '2013', '2014', '2015', '2016', '2017']
  df_KTX = pd.DataFrame(KTX_data, columns = col_list, index = index_list)
  
  print(df_KTX.head(2))
  print(df_KTX.tail(1))
  ----------------------------<결과>----------------------------
        경부선 KTX  호남선 KTX  경전선 KTX  전라선 KTX  동해선 KTX
  2011    39060     7313     	3627      	309     	 NaN
  2012    39896     6967      4168    	1771     	 NaN
        
        경부선 KTX  호남선 KTX  경전선 KTX  전라선 KTX  동해선 KTX
  2017    32427     9228     	5570     	5766  	 	6667.0
  ```

  - `df[행 시작위치 : 행 끝위치]` : data의 `행 시작위치 ~ 행 끝위치 -1`까지의 행 data를 return
    - `행 시작위치`를 생략시 0부터 시작
    - `행 시작위치`와 `행 끝위치`를 index의 이름으로도 범위 지정 가능
  - `df.loc[index_name]` : data의 index가 `index_name`인 행 데이터를 return

  ```python
  ## 행 위치 지정해서 부분 데이터 출력
  ----------------------------<코드>----------------------------
  
  print(df_KTX[1:2])
  print(df_KTX[:3])
  print(df_KTX[2:])
  
  ----------------------------<결과>----------------------------
        경부선 KTX  호남선 KTX  경전선 KTX  전라선 KTX  동해선 KTX
  2012    39896     	6967     4168     	1771      	NaN
        
        경부선 KTX  호남선 KTX  경전선 KTX  전라선 KTX  동해선 KTX
  2011    39060     	7313     3627      	309      	NaN
  2012    39896     	6967     4168     	1771     	NaN
  2013    42005     	6873     4088     	1954      	NaN
        
        경부선 KTX  호남선 KTX  경전선 KTX  전라선 KTX  동해선 KTX
  2013    42005     6873     	4088     	1954      	NaN
  2014    43621     6626     	4424     	2244      	NaN
  2015    41702     8675     	4606     	3146   		2395.0
  2016    41266    10622     	4984     	3945   		3786.0
  2017    32427     9228     	5570     	5766   		6667.0
  ```

  ```python
  ## 직접 index 이름으로 부분 데이터 출력
  ----------------------------<코드>----------------------------
  
  print(df_KTX.loc['2011'])
  print(df_KTX.loc['2013':'2016'])
  
  ----------------------------<결과>----------------------------
  경부선 KTX    39060.0
  호남선 KTX     7313.0
  경전선 KTX     3627.0
  전라선 KTX      309.0
  동해선 KTX        NaN
  Name: 2011, dtype: float64
        
        경부선 KTX  호남선 KTX  경전선 KTX  전라선 KTX  동해선 KTX
  2013    42005     6873    	 4088    	 1954     	 NaN
  2014    43621     6626    	 4424    	 2244     	 NaN
  2015    41702     8675    	 4606    	 3146  		 2395.0
  2016    41266    10622    	 4984    	 3945  		 3786.0
  ```

  - `df[column_name][start_index_name : end_index_name]`
  - `df[column_name][start_index_pos : end_index_pos]`
    - 데이터에서 하나의 열을 선택한 후 index 범위를 지정해서 원하는 데이터를 선택
    - `index_name`으로 직접 index를 지정해줘도 되고, `index_pos`로 위치로도 지정할 수 있음

  ```python
  ## df_KTX에서 '경부선 KTX'로 열을 선택 후 2012~2014년까지의 데이터를 선택
  ----------------------------<코드>----------------------------
  
  print(df_KTX['경부선 KTX']['2012':'2014'])
  print(df_KTX['경부선 KTX'][1:4])
  
  ----------------------------<결과>----------------------------
  2012    39896
  2013    42005
  2014    43621
  Name: 경부선 KTX, dtype: int64
          
  2012    39896
  2013    42005
  2014    43621
  Name: 경부선 KTX, dtype: int64
  ```

  - `df.loc[index_name][column_name]`
  - `df.loc[index_name, column_name]`
  - `df[column_name][index_name]`
  - `df[column_name][index_pos]`
  - `df[column_name].loc[index_name]`
    - 데이터 중 하나의 원소만 선택

  ```python
  ## df_KTX에서 2016년의 '호남선 KTX'의 이용자 수를 선택하는 방법
  ----------------------------<코드>----------------------------
  
  print(df_KTX.loc['2016']['호남선 KTX'])
  print(df_KTX.loc['2016', '호남선 KTX'])
  print(df_KTX['호남선 KTX']['2016'])
  print(df_KTX['호남선 KTX'][5])
  print(df_KTX['호남선 KTX'].loc['2016'])
  
  ----------------------------<결과>----------------------------
  10622.0
  10622
  10622
  10622
  10622
  ```

- #### 데이터 통합

  - ##### 세로 방향(index 증가 방향)으로 통합

    - columns가 같은 두 데이터를 세로 방향(index 증가 방향)으로 통합
    - `df1.append(df2[, ignore_index=True])` 
      - 세로방향으로 df1 다음에 df2 데이터가 추가되어서 통합된 DataFrame 데이터(df3) return
      - `ignore_index = True`를 생략하면 df3 데이터에는 기존의 index가 그대로 유지
      - `ignore_index = True`를 입력시 생성된 df3 데이터에는 데이터 순서대로 새로운 index 할당

  ```python
  ### 두 학급의 시험 점수가 담긴 df1, df2 를 생성하고, 두 데이터를 통합
  ----------------------------<코드>----------------------------
  
  df1 = pd.DataFrame({'class1' : [95, 92, 98, 100],
  					'class2' : [91, 93, 97, 99]})
  df2 = pd.DataFrame({'class1' : [87, 89],
  					'class2' : [85, 90]})
  					
  df1.append(df2)							# 기존의 index가 유지
  df1.append(df2, ignore_index = True)	# 새롭게 index 생성
  
  
  ----------------------------<결과>----------------------------
  
  	class1	class2
  0		95		91
  1		92		93
  2		98		97
  3	   100		99
  0		87		85
  1		89		90
  
  
  	class1	class2
  0		95		91
  1		92		93
  2		98		97
  3	   100		99
  4		87		85
  5		89		90
  ```

  ```python
  ## columns가 같이 않은 df 데이터를 통합
  ----------------------------<코드>----------------------------
  
  df3 = pd.DataFrame({'class1' : [96, 83]})
  df2.append(df3, ignore_index = True)
  
  ----------------------------<결과>----------------------------
  	class1	  class2	
  0		87		85.0
  1		89		90.0
  2		96		 NaN		# 데이터가 없는 부분은 NaN으로 채워짐
  3		83		 NaN
  ```

  - ##### 가로 방향(columns 증가 방향)에 데이터 추가

    - index가 같은 두 DF 데이터에 대해 가로 방향(columns 증가 방향)으로 데이터 통합
      - index label을 지정한 경우에도 index가 같으면 데이터 통합 가능
      - index가 달라도 join()으로 통합할 수는 있고, 데이터가 없는 부분은 NaN으로 표시
    - `df1.join(df2)` 
    - df1에 가로방향으로 df2의 데이터가 추가되어서 df데이터(df3)로 return

  ```python
  ## df1과 index방향으로 크기가 같은 df4 데이터 통합
  ----------------------------<코드>----------------------------
  
  df4 = pd.DataFrame({'class3' : [93, 91, 95, 98]})
  df1.join(df4)
  
  ----------------------------<결과>----------------------------
  	class1	class2	class3
  0		95		91		93
  1		92		93		91
  2		98		97		95
  3		100		99		98
  ```

  ```python
  ## index label 지정한 df 데이터 통합
  ----------------------------<코드>----------------------------
  
  index_label = ['a', 'b', 'c', 'd']
  df1a = pd.DataFrame({'class1' : [95,92,98,99],
  					 'class2' : [91,93,97,99]}, index = index_label)
  df4a = pd.DataFrame({'class3' : [93,91,95,98]}, index = index_label)
  df1a.join(df4a)
  
  ----------------------------<결과>----------------------------
  	class1	class2	class3
  a		95		91		93
  b		92		93		91
  c		98		97		95
  d		99		99		98
  ```

  ```python
  ## index 크기가 다른 두 df 데이터 통합
  ----------------------------<코드>----------------------------
  
  df5 = pd.DataFrame({'class4':[82,92]})
  df1.join(df5)
  
  ----------------------------<결과>----------------------------
  	class1	class2	class4
  0		95		91	  82.0
  1		92		93	  92.0		# NaN이 있는 해당 열은 float형으로 변환
  2		98		97	   NaN		# 데이터가 없는 부분은 NaN으로 표시
  3	   100		99	   NaN
  ```

  - ##### 특정 열을 기준으로 통함

    - 두개의 df 데이터를 특정 열을 기준으로 통합함
    - 그 특정 열을 __키(Key)__라고 함
    - 두개의 df 데이터에 공통된 열이 있다면 이 열을 기준으로 두 데이터를 통합
    - `df_left.merge(df_right)`
      - 왼쪽 데이터와 오른쪽 데이터가 key를 중심으로 좌, 우로 통합
    - `df_lef.merge(df_right, how = merge_method, on=key_label)`
      - `on`인자는 통합하려는 key열의 라벨 이름(`key_label`) 입력
      - `on`인자 생략시 자동으로 두 데이터에서 공통적으로 포함된 열 선택
      - `how`인자는 key열을 기준으로 통합 방법(`merge_method`) 지정
        - `merge_method`에는 `left` / `right` / `outer` / `inner` 이 있음

  ```python
  ## 공통 열을 가지는 두 df 데이터 통합
  ----------------------------<코드>----------------------------
  
  df_A_B = pd.DataFrame({'판매월':['1월', '2월', '3월', '4월'],
  					   '제품A':[100, 150, 200, 130],
  					   '제품B':[90, 110, 140, 170]})
  df_C_D = pd.DataFrame({'판매월':['1월', '2월', '3월', '4월'],
  					   '제품C':[112, 141, 203, 134],
  					   '제품D':[99, 100, 120, 179]})
  df_A_B.merge(df_C_D)
  
  ----------------------------<결과>----------------------------
  	판매월	제품A	 제품B  제품C	제품D
  0	1월	  100	 90	   112	   99
  1	2월	  150	110	   141	   100
  2	3월	  200	140	   203	   120
  3	4월	  130	170	   134	   179
  ```

  ```python
  ## merge_method에 따라 달라지는 통합 
  ----------------------------<코드>----------------------------
  
  df_left = pd.DataFrame({'key':['A', 'B', "C"], 'left': [1,2,3]})
  df_right = pd.DataFrame({'key':['A','B','D'], 'right': [4,5,6]})	# key가 하나 다름
  
  print(df_left.merge(df_right, how='left', on='key'))
  print(df_left.merge(df_right, how='right', on='key'))
  print(df_left.merge(df_right, how='outer', on='key'))
  print(df_left.merge(df_right, how='inner', on='key'))
  
  ----------------------------<결과>----------------------------
  	key  left  right	# left merge : left의 key를 기준으로 통합
  0   A     1    4.0
  1   B     2    5.0
  2   C     3    NaN
  
  	key  left  right	# right merge : right의 key 기준으로 통합
  0   A   1.0      4
  1   B   2.0      5
  2   D   NaN      6
   
   	key  left  right	# outer merge : left, right key 모두 적용
  0   A   1.0    4.0
  1   B   2.0    5.0
  2   C   3.0    NaN
  3   D   NaN    6.0
   
   	key  left  right	# inner merge : left, right의 공통key만 적용
  0   A     1      4
  1   B     2      5
  ```

- #### 데이터 파일 읽고 쓰기

  > 표 형식의 데이터파일을 DataFrame 형식의 데이터로 읽어오는 방법과
  >
  > DataFrame 형식의 데이터를 표 형식의 파일로 저장하는 방법을 제공

  - ##### 표 형식의 데이터 파일 읽기

    - `df = pd.read_csv(file_name [, options])`
      - 표 형식의 텍스트 데이터 파일을 읽기
      - 기본적으로 각 데이터 필드가 콤마`,`로 구분된 CSV 파일을 읽는데 이용
      - `file_name`: 텍스트 파일의 이름으로 경로를 포함
      - 데이터파일의 구분자가 콤마가 아닌경우 `sep=구분자`option을 추가해야 읽어오기 가능

  ```python
  ### CSV 파일 생성 후 읽어오기
  ----------------------------<코드>----------------------------
  
  %%writefile sea_rain1.csv
  연도,동해,남해,서해,전체
  1996,17.4629,17.2288,14.4360,15.9067
  1997,17.4116,17.4092,14.8248,16.1526
  1998,17.5944,18.0110,15.2512,16.6044
  1999,18.1495,18.3175,14.8979,16.6284
  2000,17.9288,18.1766,15.0504,16.6178
  
  -------------------------------------------------------------
  
  pd.read_csv('sea_rain1.csv')
  pd.read_csv('sea_rain1_from_notepad.csv', encoding = "cp949")
  
  ----------------------------<결과>----------------------------
  	연도     동해     남해      서해      전체	
  0  1996  17.4629  17.2288  14.4360  15.9067
  1  1997  17.4116  17.4092  14.8248  16.1526
  2  1998  17.5944  18.0110  15.2512  16.6044
  3  1999  18.1495  18.3175  14.8979  16.6284
  4  2000  17.9288  18.1766  15.0504  16.6178
  ```

  ```python
  ## 콤마가 아닌 빈칸으로 구분되어 있는 텍스트 파일 읽어오기
  ----------------------------<코드>----------------------------
  
  %%writefile sea_rain2.csv
  연도 동해 남해 서해 전체
  1996 17.4629 17.2288 14.4360 15.9067
  1997 17.4116 17.4092 14.8248 16.1526
  1998 17.5944 18.0110 15.2512 16.6044
  1999 18.1495 18.3175 14.8979 16.6284
  2000 17.9288 18.1766 15.0504 16.6178
  
  -------------------------------------------------------------
  
  pd.read_csv('sea_rain2.csv', sep=' ')
  
  ----------------------------<결과>----------------------------
   	연도     동해     남해      서해      전체
  0  1996  17.4629  17.2288  14.4360  15.9067
  1  1997  17.4116  17.4092  14.8248  16.1526
  2  1998  17.5944  18.0110  15.2512  16.6044
  3  1999  18.1495  18.3175  14.8979  16.6284
  4  2000  17.9288  18.1766  15.0504  16.6178
  ```

  ```python
  ## csv 파일에서 '연도' 열을 index로 선택해서 DF 형식으로 데이터 읽어오기
  ----------------------------<코드>----------------------------
  
  pd.read_csv('sea_rain1.csv', index_col = '연도')
  
  ----------------------------<결과>----------------------------
   		동해       남해    서해      전체
  연도                                      
  1996  17.4629  17.2288  14.4360  15.9067
  1997  17.4116  17.4092  14.8248  16.1526
  1998  17.5944  18.0110  15.2512  16.6044
  1999  18.1495  18.3175  14.8979  16.6284
  2000  17.9288  18.1766  15.0504  16.6178
  ```

  - ##### table 형식의 데이터를 file로 쓰기

    - DF 형식의 데이터를 텍스트 파일로 저장
    - `df.to_csv(file_name[, options]`
      - `file_name`은 텍스트 파일 이름으로 경로를 포함
      - `options`에는 구분자, 문자의 인코딩 방식 등을 지정
        - 지정하지 않으면 구분자는 콤마`,`이고 문자의 인코딩 방식은 `utf-8`로 default

  ```python
  ## df 데이터 생성 후 csv파일로 저장
  ## 네 명의 몸무게와 키 데이터를 생성 후 체질량 지수(bmi) 추가
  ----------------------------<코드>----------------------------
  
  df_WH = pd.DataFrame({'Weight':[62,67,55,74], 'Height':[165,177,160,180]},
  						index = ['ID_1', 'ID_2', 'ID_3', 'ID_4'])
  						
  df_WH.index.name = 'User'	# index.name으로 index 이름 추가
  
  bmi = df_WH['Weight']/(df_WH['Height']/100)**2
  df_WH['BMI'] = bmi		# df데이터에 새로운 열 데이터(BMI)를 추가
  
  df_WH.to_csv('save_DataFrame.csv')
  !cat save_DataFrame.csv			# 저장되었는지 확인
  
  ----------------------------<결과>----------------------------
  User,Weight,Height,BMI
  ID_1,62,165,22.77318640955005
  ID_2,67,177,21.38593635289987
  ID_3,55,160,21.484374999999996
  ID_4,74,180,22.839506172839506
  ```

  























































