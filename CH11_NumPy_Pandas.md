# Python CH.11 데이터 분석을 위한 패키지

# NumPy & Pandas



## 11.1 NumPy : 배열 데이터를 효과적으로 다루기

> python에서 과학 연산을 효율적으로 할 수 있도록 외부 패키지인 NumPy를 사용
>
> python의 기본 데이터 형식이나 내장 함수를 이용하는 것보다 다차원 배열 데이터를 효과적으로 처리 가능
>
> NumPy에 대한 정보 :  [NumPy홈페이지](http://www.numpy.org)

- #### 배열 생성하기

  - 배열(Array) : 같은 종류의 데이터들이 순서대로 저장된 집합
  - NumPy로 배열을 처리하기 위해서는 NumPy로 배열을 생성해야함
  - 설치된 NumPy를 이용하기 위해서는 먼저 NumPy 패키지를 불러와야 함
    - 한 번만 불러오면 코드 내에서는 NumPy 사용 가능
  - `import numpy as 별명` : NumPy 패키지를 불러오고 이를 `별명`으로 호출 할 수 있음

  ```python
  import numpy as np 			# numpy 패키지를 불러오고 이를 np로 지정함
  ```

  - `arr_obj = np.array(seq_data)` 
    - 시퀀스 데이터`seq_data`를 인자로 받아 NumPy의 배열 객체를 생성 후, `arr_obj`에 저장함
    - 시퀀스 데이터`seq_data`로는 list, tuple 타입의 데이터를 모두 사용 가능(주로 list를 이용)
    - 정수와 실수가 혼합이 되어 있다면 모두 실수로 변환하여 실수 배열을 생성함

  ```python
  ## list로부터 NumPy의 1차원 배열을 생성
  ----------------------------<코드>----------------------------
  
  import numpy as np
  
  data1 = [0, 1, 2, 3, 4, 5]		# 리스트를 생성
  a1 = np.array(data1)			# 생성한 리스트를 array()인자로 넣어 NumPy 배열 생성
  a1
  
  ----------------------------<결과>----------------------------
  array([0, 1, 2, 3, 4, 5])
  ```

  ```python
  ## 실수와 정수가 혼합되어 있는 리스트 데이터로 NumPy 배열 생성
  ----------------------------<코드>----------------------------
  
  data2 = [0, 1.5, 2, 3.7, 4, 5.2]		# 실수와 정수가 혼합되어 있는 리스트
  a2 = np.array(data2)			
  a2
  
  ----------------------------<결과>----------------------------
  array([0. , 1.5, 2. , 3.7, 4. , 5.2])	# 정수 또한 모두 실수로 변환되어 실수 배열이 생성됨
  ```

  - `arr_obj = np.array([list])`
    - `array()`함수 인자로 직접 리스트 데이터를 넣어서 배열 객체를 생성 할 수 있음
    - 인자에 `[[list_data], [list_data], ... , [list_data]]`로 넣어 다차원 배열도 생성 가능

  ```python
  ## array()에 인자로 직접 리스트 데이터를 넣어서 배열 객체 생성
  ----------------------------<코드>----------------------------
  
  a3 = np.array([0.5, 2, 0.01, 8])
  a3
  
  ----------------------------<결과>----------------------------
  array([0.5 , 2.  , 0.01, 8.  ])
  ```

  ```python
  ## array()를 이용하여 다차원 배열 객체 생성
  ----------------------------<코드>----------------------------
  
  a4 = np.array([[1,2,3], [4,5,6]])		# 2차원(2X3) 배열 생성
  a4
  
  ----------------------------<결과>----------------------------
  array([[1, 2, 3],
         [4, 5, 6]])
  ```

  - `arr_obj = np.arange([start,] stop [,step])`
    - `start`부터 시작해서 `stop`전까지(`stop - 1` 까지) `step`만큼 더해서 NumPy 배열을 생성
    - `start`는 0인 경우 생략 가능,  `step`은 1인 경우 생략 가능

  ```python
  ## np.arange() 사용해서 배열 생성
  ----------------------------<코드>----------------------------
  
  ar1 = np.arange(0,10,2)		# 0부터 9까지 2씩 더한 수들로 배열 생성
  ar2 = np.arange(1,10)		# step 생략하고 1부터 9까지 1씩 더한 수들로 배열 생성
  ar3 = np.arange(5)			# star, step 생략하고 0부터 4까지 1씩 더한 수들로 배열 생성
  
  print(ar1)
  print(ar2)
  print(ar3)
  
  ----------------------------<결과>----------------------------
  [0 2 4 6 8]
  [1 2 3 4 5 6 7 8 9]
  [0 1 2 3 4]
  ```

  - `arr_obj = np.arange().reshape(m,n)`
    - `arange()`로 만든 1차원 배열에 `reshape(m,n)`을 추가하여 m x n 형태의 2차원 배열(행렬)로 변경
    - NumPy 배열에서 행과 열의 위치(index)는 0부터 시작
    - `arange()`로 생성되는 원소 개수와 `reshape(m,n)`에서의 m x n 개수는 같아야함
    - `arr_obj.shape` : 배열의 형태를 확인

  ```python
  ## np.arange().reshape(m,n)을 이용하여 2차원 배열 생성
  ----------------------------<코드>----------------------------
  
  ar4 = np.arange(12).reshape(4,3)	# 0부터 11까지 12개의 원소를 4x3행렬(배열)로 생성
  ar5 = np.arange(1,10).reshape(3,3)	# 1부터 9까지 9개의 원소를 3x3 배열로 생성
  ar6 = np.arange(1,24,2).reshape(2,6) # 1부터 23까지 2씩 건너뛰며 만든 12개의 원소로 2x6 배열
  ar7 = np.arange(10)			# 0부터 9까지 10개의 원소를 1차원 배열로 생성
  
  print(ar4)
  print(ar4.shape, '\n')		# 배열의 형태 확인
  print(ar5)
  print(ar5.shape, '\n')
  print(ar6)
  print(ar6.shape, '\n')
  print(ar7)
  print(ar7.shape)
  
  
  ----------------------------<결과>----------------------------
  [[ 0  1  2]
   [ 3  4  5]
   [ 6  7  8]
   [ 9 10 11]]
  (4, 3) 
  
  [[1 2 3]
   [4 5 6]
   [7 8 9]]
  (3, 3) 
  
  [[ 1  3  5  7  9 11]
   [13 15 17 19 21 23]]
  (2, 6) 
  
  [0 1 2 3 4 5 6 7 8 9]
  (10,)					# 1차원 배열의 형태는 (n, )로 출력
  ```

  - `arr_obj = np.linspace(start, stop[, num])` 
    - 범위의 시작과 끝을 지정하고 데이터의 개수를 지정해 NumPy 배열을 생성
    - `start`부터 `stop`까지 `num`개의 NumPy 배열을 생성함
    - `num`은 생략 가능하며, 생략시에는 50으로 default

  ```python
  ## np.linspace()함수를 이용하여 배열 생성
  ----------------------------<코드>----------------------------
  
  lar1 = np.linspace(1, 10, 10)	# 1부터 10까지 10개의 데이터로 1차원 배열 생성
  lar2 = np.linspace(0, np.pi, 20)  # 0부터 pi(3.141592..)까지 동일한 간격으로 나눈 20개의 
  								  # 데이터로 1차원 배열 새성
  lar3 = np.linspace(1,12,12).reshape(3,4)	# 12개의 데이터로 3x4 2차원 배열 생성
  
  print(lar1)
  print(lar2)
  print(lar3)
  
  ----------------------------<결과>----------------------------
  [ 1.  2.  3.  4.  5.  6.  7.  8.  9. 10.]
  
  [0.         0.16534698 0.33069396 0.49604095 0.66138793 0.82673491
   0.99208189 1.15742887 1.32277585 1.48812284 1.65346982 1.8188168
   1.98416378 2.14951076 2.31485774 2.48020473 2.64555171 2.81089869
   2.97624567 3.14159265]
  
  [[ 1.  2.  3.  4.]
   [ 5.  6.  7.  8.]
   [ 9. 10. 11. 12.]]
  ```

  - `np.zeros(n)` / `np.zeros((m,n))`
    - 모든 원소가 0인 1차원 / 2차원(mxn) 배열 생성	
  - `np.ones(n)` / `np.ones((m,n))`
    - 모든 원소가 1인 1차원 / 2차원(mxn) 배열 생성

  ```python
  ## 모든 원소가 0인 배열 생성
  ----------------------------<코드>----------------------------
  
  arz1 = np.zeros(5)
  arz2 = np.zeros((5,3))
  
  print(arz1)
  print(arz2)
  
  ----------------------------<결과>----------------------------
  [0. 0. 0. 0. 0.]		# np.zeros()에서 원소 0은 정수가 아닌 실수
  
  [[0. 0. 0.]
   [0. 0. 0.]
   [0. 0. 0.]
   [0. 0. 0.]
   [0. 0. 0.]]
  ```

  ```python
  ## 모든 원소가 1인 배열 생성
  ----------------------------<코드>----------------------------
  
  aro1 = np.ones(4)
  aro2 = np.ones((4,6))
  
  print(aro1)
  print(aro2)
  
  ----------------------------<결과>----------------------------
  [1. 1. 1. 1.]			# np.ones()에서 원소1은 정수가 아닌 실수
  
  [[1. 1. 1. 1. 1. 1.]
   [1. 1. 1. 1. 1. 1.]
   [1. 1. 1. 1. 1. 1.]
   [1. 1. 1. 1. 1. 1.]]
  ```

  - `np.eye(n)` 
    - nxn 단위행렬을 갖는 2차원 배열 생성 
    - 단위행렬이란 주 대각선의 원소가 1이고 나머지 원소는 0인 행렬

  ```python
  ## np.eye()로 단위행렬을 갖는 배열 생성
  ----------------------------<코드>----------------------------
  
  are1 = np.eye(3)
  are2 = np.eye(5)
  are3 = np.eye(2)
  
  print(are1)
  print(are2)
  print(are3)
  
  ----------------------------<결과>----------------------------
  [[1. 0. 0.]
   [0. 1. 0.]
   [0. 0. 1.]]
   
  [[1. 0. 0. 0. 0.]
   [0. 1. 0. 0. 0.]
   [0. 0. 1. 0. 0.]
   [0. 0. 0. 1. 0.]
   [0. 0. 0. 0. 1.]]
   
  [[1. 0.]
   [0. 1.]]
  ```

- #### 데이터 타입 확인

  - `arr_obj.dtype` 	

    - 배열 객체의 타입을 확인

  - NumPy 데이터 형식

    |   기호    | 의미                                                |
    | :-------: | :-------------------------------------------------- |
    |    'b'    | 불[bool]                                            |
    |    'i'    | 기호가 있는 정수[signed integer]                    |
    |    'u'    | 기호가 없는 정수[unsigned integer]                  |
    |    'f'    | 실수[floating-point]                                |
    |    'c'    | 복소수[complex-floating point]                      |
    |    'M'    | 날짜[datetime]                                      |
    |    'O'    | 파이썬객체[Python objects]                          |
    | 'S' / 'a' | 바이트 문자열[byte string]                          |
    |    'U'    | 유니코드[Unicode] (뒤의 붙는 숫자는 최대 문자의 수) |



- #### 배열의 데이터 타입 변환

  - `tran_arr = arr_obj.astype(dtype)`
    - arr_obj의 배열을 dtype 타입으로 변환하고, 변환된 배열 객체를 tran_arr에 대입
    - 문자열로 구성된 배열의 모든 원소를 정수나 실수로 변환 또는 정수/실수를 문자열로 변환
    - 정수를 실수로 변환 또는 실수를 정수로 변환

  ```python
  ## 문자열을 원소로 갖는 NumPy 배열을 실수타입으로 변환
  ----------------------------<코드>----------------------------
  
  str_ar1 = np.array(['1.234', '0.123', '5.123', '9', '3'])
  num_ar1 = str_ar1.astype(float)		# 문자열인 원소를 실수로 변환
  print(num_ar1)
  
  print(str_ar1.dtype)
  print(num_ar1.dtype)
  
  ----------------------------<결과>----------------------------
  [1.234 0.123 5.123 9.    3.   ]
  <U5			# 최대 문자수가 5인 유니코드 데이터타입(문자열)
  float64		# 64비트의 실수형
  ```

  ```python
  ## 문자열을 원소로 갖는 numpy 배열을 정수타입으로 변환
  ----------------------------<코드>----------------------------
  
  str_ar2 = np.array(['1', '2', '3', '4'])
  num_ar2 = str_ar2.astype(int)		# 문자열인 원소를 정수로 변환
  print(num_ar2)
  
  print(str_ar2.dtype)
  print(num_ar2.dtype)
  
  ----------------------------<결과>----------------------------
  [1 2 3 4]
  <U1			# 최대문자수가 1인 유니코드 데이터타입(문자열)
  int64		# 64비트의 정수형
  ```

  ```python
  ## 실수를 원소로 갖는 numpy 배열을 정수형으로 변환
  ----------------------------<코드>----------------------------
  
  num_f1 = np.array([10, 21, 3.13, 2.72, 5.84])
  num_i1 = num_f1.astype(int)
  print(num_i1)
  
  print(num_f1.dtype)
  print(num_i1.dtype)
  
  ----------------------------<결과>----------------------------
  [10 21  3  2  5]
  float64
  int64
  ```



- #### 난수 배열 생성

  > random 모듈을 이용하여 임의의 숫자인 난수(random number)를 생성

  - `np.random.rand(d1, d2, ... , dn)`
    - [0,1) 범위의 실수 난수를 원소로 갖는 배열 생성
    - `rand()`에 인자가 없으면 난수 1개를 생성
    - `d1, d2, ... , dn` 은 배열의 크기
  - `np.random.randint([low,] high [,size])`
    - [low, high) 사이의 정수 난수를 원소로 갖는 배열 생성
    - `low`가 생략되면 0으로 간주하고, `size`가 생략되면 1로 간주함
    - `size = (d1, d2, ... , dn)`으로 입력해서 크기를 지정

  ```python
  ## rand()을 이용하여 실수 난수를 원소로 갖는 배열 생성
  ----------------------------<코드>----------------------------
  
  ran_arr1 = np.random.rand()
  ran_arr2 = np.random.rand(3)
  ran_arr3 = np.random.rand(2,3)
  ran_arr4 = np.random.rand(2,3,4)
  
  print(ran_arr1)
  print()
  print(ran_arr2)
  print()
  print(ran_arr3)
  print()
  print(ran_arr4)
  
  ----------------------------<결과>----------------------------
  0.44824395969215336						# 실수 1개 
  	
  [0.15747727 0.6874496  0.29830424]		# 원소가 3개인 1차원 배열
  
  [[0.81029893 0.66345291 0.37985234]
   [0.47439082 0.71376514 0.25358668]]	# 2x3인 2차원 배열
  
  [[[0.25357439 0.26794274 0.04588856 0.99637639]
    [0.87959056 0.45172073 0.01973225 0.02945277]
    [0.4701212  0.00228858 0.40887994 0.76236931]]
  
   [[0.2796868  0.01650915 0.19587565 0.47992455]
    [0.38996545 0.64219117 0.34302551 0.55801736]		# 2x3x4인 3차원 배열
    [0.842475   0.43343198 0.1603189  0.62443745]]]
  ```

  ```python
  ## randint()을 이용해서 정수 난수를 원소로 갖는 배열 생성
  ----------------------------<코드>----------------------------
  
  rani_arr1 = np.random.randint(6)	# 0부터 5까지의 난수 1개 
  rani_arr2 = np.random.randint(1,10) # 1부터 9까지의 난수 1개
  rani_arr3 = np.random.randint(1,30, size=(5))	# 1~29 5개의 난수를 원소로 갖는 1차원 배열
  rani_arr4 = np.random.randint(1,30, size=(3,4))	# 1~29 난수를 원소로 갖는 3x4배열 생성
  rani_arr5 = np.random.randint(20, size=(2,3,4))	# 0~19 난수를 원소로 갖는 2x3x4배열 생성
  
  print(rani_arr1)
  print(rani_arr2)
  print(rani_arr3)
  print(rani_arr4)
  print(rani_arr5)
  
  ----------------------------<결과>----------------------------
  0
  9
  
  [ 5  7 22 27 24]
  
  [[13 28 12 18]
   [21 16 21  4]
   [21 26 23 10]]
   
  [[[12 16 18 12]
    [10  4 12 13]
    [13  6 11 13]]
  
   [[ 0  3 11  4]
    [ 3  2  5 15]
    [ 9  4 16  7]]]
  ```



- #### 배열의 기본 연산

  > __배열의 형태가 같은__ 배열끼리는 `+`, `-`, `*`, `**`, `/` , 비교 연산까지 가능
  >
  > 배열이 형태가 같다는 것은 `arr_obj.shape`결과가 같아야 함(행과 열의 개수가 일치해야함)

  | 연산     | 의미                        | 사용 예                    |
  | -------- | --------------------------- | -------------------------- |
  | +        | 같은 위치의 원소들의 합     | arr1 + arr2                |
  | -        | 같은 위치의 원소들의 차     | arr1 - arr2                |
  | * (상수) | 각 원소에 (상수)를 곱함     | arr1 * 2                   |
  | *        | 같은 위치의 원소들의 곱     | arr1 * arr2                |
  | **       | 각 원소에 거듭제곱          | arr1 ** 3                  |
  | /        | 같은 위치의 원소끼리 나눔   | arr2 / arr1                |
  | 비교연산 | 같은위치의 원소들끼리  비교 | arr1 > 20 <br />arr1<=arr2 |

  ```python
  ## 배열의 기본 연산
  ----------------------------<코드>----------------------------
  
  arr1 = np.array([[1,2,3], [4,5,6]])		# 2x3인 배열
  arr2 = np.array([[2,4,3], [2,10,12]])		# 2x3인 배열
  
  # 더하기 연산
  arr_res1 = arr1 + arr2
  print("===== 배열의 더하기 연산 =====")
  print(arr_res1)
  
  # 빼기 연산
  arr_res2 = arr2 - arr1
  print("===== 배열의 빼기 연산 =====")
  print(arr_res2)
  
  # 상수배 연산
  arr_res3 = arr1 * 5
  print("===== 배열의 상수배 연산 =====")
  print(arr_res3)
  
  # 곱하기 연산
  arr_res4 = arr1 * arr2
  print("===== 배열의 곱하기 연산 =====")
  print(arr_res4)
  
  # 거듭제곱 연산
  arr_res5 = arr1 ** 2
  print("===== 배열의 거듭제곱 연산 =====")
  print(arr_res5)
  
  # 나누기 연산
  arr_res6 = arr2 / arr1
  print("===== 배열의 나누기 연산 =====")
  print(arr_res6)
  
  # 비교 연산
  arr_res7 = arr2 <= arr1
  arr_res8 = arr2 > 3
  print("===== 배열의 비교 연산 =====")
  print(arr_res7)
  print()
  print(arr_res8)
  
  ----------------------------<결과>----------------------------
  ===== 배열의 더하기 연산 =====
  [[ 3  6  6]
   [ 6 15 18]]
  ===== 배열의 빼기 연산 =====
  [[ 1  2  0]
   [-2  5  6]]
  ===== 배열의 상수배 연산 =====
  [[ 5 10 15]
   [20 25 30]]
  ===== 배열의 곱하기 연산 =====
  [[ 2  8  9]
   [ 8 50 72]]
  ===== 배열의 거듭제곱 연산 =====
  [[ 1  4  9]
   [16 25 36]]
  ===== 배열의 나누기 연산 =====
  [[2.  2.  1. ]
   [0.5 2.  2. ]]
  ===== 배열의 비교 연산 =====
  [[False False  True]
   [ True False False]]
  
  [[False  True False]
   [False  True  True]]
  ```

- #### 통계 연산

  > NumPy에서는 배열의 합, 평균, 표준편차, 분산, 최댓값, 최솟값, 누적 합, 누적 곱 등 
  > 통계에 많이 사용되는 연산을 메서드를 이용하여 할 수 있음

  |  메서드   |            의미             |      사용 예      |
  | :-------: | :-------------------------: | :---------------: |
  |   sum()   |    배열 원소의 합을 구함    |   arr_obj.sum()   |
  |  mean()   |   배열 원소의 평균을 구함   |  arr_obj.mean()   |
  |   std()   | 배열 원소의 표준편차를 구함 |   arr_obj.std()   |
  |   var()   |   배열 원소의 분산을 구함   |   arr_obj.var()   |
  |   min()   | 배열 원소 중 최솟값을 구함  |   arr_obj.min()   |
  |   max()   | 배열 원소 중 최댓값을 구함  |   arr_obj.max()   |
  | cumsum()  |  배열 원소의 누적합을 구함  | arr_obj.cumsum()  |
  | cumprod() |  배열 원소의 누적곱을 구함  | arr_obj.cumprod() |

  ```python
  ## 배열의 통계 연산
  ----------------------------<코드>----------------------------
  
  arr3 = np.random.randint(1,3, size =(2,3))	# 1부터 3까지의 정수 난수를 원소로하는 2x3배열
  print("arr3 배열")
  print(arr3)
  
  # 합 구하기
  res1 = arr3.sum()
  print("===== 배열의 합 =====")
  print(res1)
  
  # 평균 구하기
  res2 = arr3.mean()
  print("===== 배열의 평균 =====")
  print(res2)
  
  # 표준편차 구하기
  res3 = arr3.std()
  print("===== 배열의 표준편차 =====")
  print(res3)
  
  # 분산 구하기
  res4 = arr3.var()
  print("===== 배열의 분산 =====")
  print(res4)
  
  # 최댓값 구하기
  res5 = arr3.max()
  print("===== 배열의 최댓값 =====")
  print(res5)
  
  # 최솟값 구하기
  res6 = arr3.min()
  print("===== 배열의 최솟값 =====")
  print(res6)
  
  # 누적합 구하기
  arr_res7 = arr3.cumsum()
  print("===== 배열의 누적합 =====")
  print(arr_res7)
  
  # 누적곱 구하기
  arr_res8 = arr3.cumprod()
  print("===== 배열의 누적곱 =====")
  print(arr_res8)
  
  ----------------------------<결과>----------------------------
  arr3 배열
  [[1 2 1]
   [2 1 1]]
  ===== 배열의 합 =====
  8
  ===== 배열의 평균 =====
  1.3333333333333333
  ===== 배열의 표준편차 =====
  0.4714045207910317
  ===== 배열의 분산 =====
  0.22222222222222224
  ===== 배열의 최댓값 =====
  2
  ===== 배열의 최솟값 =====
  1
  ===== 배열의 누적합 =====
  [1 3 4 6 7 8]
  ===== 배열의 누적곱 =====
  [1 2 2 4 4 4]
  ```



- #### 행렬 연산

  > NumPy는 배열의 연산뿐 아니라 선형대수를 위한 행렬(2차원 배열)연산도 가능
  >
  > 행렬 곱, 전치 행렬, 역행렬, 행렬식 구하기

  |         행렬 연산          |              사용 예               |
  | :------------------------: | :--------------------------------: |
  |  행렬 곱(matrix product)   |     A.dot(B) 또는 np.dot(A,B)      |
  | 전치행렬(transpose matrix) | A.transpose() 또는 np.transpose(A) |
  |   역행렬(inverse matrix)   |          np.linalg.inv(A)          |
  |    행렬식(determinant)     |          np.linalg.det(A)          |

  ```python
  ## 행렬 연산 (행렬 연산을 위해 2x2 배열 A, B 생성 후 연산)
  ----------------------------<코드>----------------------------
  
  A = np.array([1,2,2,3]).reshape(2,2)
  B = np.array([3,2,1,2]).reshape(2,2)
  
  # 행렬곱 구하기
  mat_res1 = A.dot(B)		# 또는 np.dot(A,B)
  print("===== 행렬곱 =====")
  print(mat_res1)
  
  # 전치행렬 구하기
  mat_res2 = np.transpose(A)
  mat_res3 = B.transpose()
  print("===== A의 전치행렬 =====")
  print(mat_res2)
  print("===== B의 전치행렬 =====")
  print(mat_res3)
  
  # 역행렬 구하기
  mat_res4 = np.linalg.inv(A)
  mat_res5 = np.linalg.inv(B)
  print("===== A의 역행렬 =====")
  print(mat_res4)
  print("===== B의 역행렬 =====")
  print(mat_res5)
  
  # det(A)/ det(B) 구하기
  res6 = np.linalg.det(A)
  res7 = np.linalg.det(B)
  print("===== det(A) 구하기 =====")
  print(res6)
  print("===== det(B) 구하기 =====")
  print(res7)
  
  ----------------------------<결과>----------------------------
  ===== 행렬곱 =====
  [[ 5  6]
   [ 9 10]]
  ===== A의 전치행렬 =====
  [[1 2]
   [2 3]]
  ===== B의 전치행렬 =====
  [[3 1]
   [2 2]]
  ===== A의 역행렬 =====
  [[-3.  2.]
   [ 2. -1.]]
  ===== B의 역행렬 =====
  [[ 0.5  -0.5 ]
   [-0.25  0.75]]
  ===== det(A) 구하기 =====
  -1.0
  ===== det(B) 구하기 =====
  4.000000000000001
  ```

  

- #### 배열의 인덱싱(Indexing) & 슬라이싱(Slicing)

  > 배열의 위치, 조건, 범위를 지정해서 필요한 원소를 선택하는 작업이 필요
  >
  > 배열에서 선택된 원소의 값을 가져오거나 변경하는 등.

  - #### 인덱싱(Indexing)

    - 배열의 위치나 조건을 지정해서 배열의 원소를 선택하는 것
    - 1차원 배열에서 특정 원소를 선택하기 위해 원소의 위치를 지정
      - `배열명[위치]` 로 해당 원소를 불러오기
      - 배열의 위치(Index)는 0부터 시작
      - `배열명[[위치1, 위치2, ... , 위치n]]`으로 해당 위치의 원소들을 여러 개 가져오기 가능
    - 2차원 배열에서 특정 원소의 위치 지정 
      - `배열명[행_위치],[열_위치]`로 해당 원소 불러오기
      - `열_위치` 가 생략된다면 지정한 행 전체가 선택됨
      - `배열명[행_위치1, ... , 행_위치n],[열_위치1, ... , 열_위치n]`으로 여러 개의 원소 선택 
    - 조건을 지정하여 만족하는 원소 선택 가능
      - `배열명[조건]` 으로 조건을 만족하는 원소들을 선택

    ```python
    ## 인덱싱 실습
    ----------------------------<코드>----------------------------
    
    a1 = np.array([0, 10, 20, 30, 40, 50])		# 1차원 배열 생성
    
    print('a1[0] = ', a1[0])
    print('a1[4] = ', a1[4])		# 배열에서 인덱스가 4에 해당하는 원소 출력
    
    a1[5] = 70					# 6번째 원소(50)의 값을 70으로 변경
    print("modified a1")
    print(a1)
    
    print('a1[[1,3,4]] = ', a1[[1,3,4]])	# 인덱스가 1, 3, 4인 원소들을 모두 출력
    
    a2 = np.arange(10,100,10).reshape(3,3)	# 2차원 배열 생성
    print('a2')
    print(a2)
    
    print('a2[0,2] = ', a2[0,2])	# (0,2) 위치의 원소 출력
    
    a2[2,2] = 95			# (2,2)위치의 원소 값을 95로 변경
    print('modified a2')
    print(a2)
    
    print('a2[1] = ', a2[1])	# 두번째 행 전체 출력
    
    a2[1] = np.array([45,55,65])	# 두번째 행 전체의 값을 변경
    print('modified a2')
    print(a2)
    
    a2[2] = [47,57,67]		# 세번쨰 행 전체의 값을 변경
    print('modified a2')
    print(a2)
    
    print('a2의 (0,0), (2,1) = ', a2[[0,2],[0,1]]) 	# (0,0), (2,1) 원소 동시에 출력
    
    a = np.array([1,2,3,4,5,6])		# 새로운 1차원 배열 생성
    print("3보다 큰 원소 : ", a[a>3])	# 조건을 만족하는 원소 출력
    
    ----------------------------<결과>----------------------------
    a1[0] =  0
    a1[4] =  40
    modified a1
    [ 0 10 20 30 40 70]
    a1[[1,3,4]] =  [10 30 40]
    a2
    [[10 20 30]
     [40 50 60]
     [70 80 90]]
    a2[0,2] =  30
    modified a2
    [[10 20 30]
     [40 50 60]
     [70 80 95]]
    a2[1] =  [40 50 60]
    modified a2
    [[10 20 30]
     [45 55 65]
     [70 80 95]]
    modified a2
    [[10 20 30]
     [45 55 65]
     [47 57 67]]
    a2의 (0,0), (2,1) =  [10 57]
    3보다 큰 원소 :  [4 5 6]
    ```

  - #### 슬라이싱(Slicing)

    - 범위를 지정하여 배열의 일부분을 선택
    - 1차원 배열
      - `배열[시작_위치:끝_위치]` 
      - return되는 원소의 범위는 시작위치 ~ 끝위치-1 
      - 시작위치를 생략하면 0이 됨
      - 끝위치를 생략하면 배열의 길이(배열의 끝)이 됨
    - 2차원 배열
      - `배열[행시작위치:행끝위치, 열시작위치:열끝위치]`
      - 행의 범위는 행시작위치~행끝위치-1, 열의 범위는 열시작위치~열끝위치-1
      - 행시작위치나 열시작위치를 생략하면 0이됨
      - 행끝위치나 열끝위치를 생략하면 각각 행의 끝까지, 열의 끝가지로 됨
      - `배열[행위치][열시작위치:열끝위치]` 로 행은 정해져있고 열로 범위를 선택 가능

    ```python
    ## 슬라이싱 실습
    ----------------------------<코드>----------------------------
    
    b1 = np.array([0,10,20,30,40,50])
    
    print('b1[1:4] : ', b1[1:4])	# b1의 인덱스가 1~3까지의 원소 출력
    print('b1[:3] : ', b1[:3])		# b1의 인덱스가 0~2까지의 원소 출력
    print('b1[2:] : ', b1[2:])		# b1의 인덱스가 2~5까지의 원소 출력
    
    b1[2:5] = np.array([25, 35, 45])	# 범위 지정해서 원소의 값 변경
    print('modified b1')
    print(b1)
    
    b1[3:6] = 60		# 범위의 원소들을 하나의 값으로 변경(모두 60으로 변경)
    print('modified b1')
    print(b1)
    
    b2 = np.arange(10,100,10).reshape(3,3)	
    print('b2')
    print(b2)
    
    print('b2[1:3, 1:3] : ', b2[1:3, 1:3])	# 행, 열이 1~2 인덱스인 범위의 원소 출력
    print('b2[:3, 1:] :' , b2[:3, 1:])	# 0~2의 행, 1~2까지의 열의 원소 출력
    
    print('b2[1][0:2] : ',b2[1][0:2] ) # 1행에서 0~1열의 원소 출력
    
    b2[0:2, 1:3] = np.array([[25,35],[55,65]])	# 범위 지정해서 원소 값 변경
    print('modified b2')
    print(b2)
    
    ----------------------------<결과>----------------------------
    b1[1:4] :  [10 20 30]
    b1[:3] :  [ 0 10 20]
    b1[2:] :  [20 30 40 50]
    modified b1
    [ 0 10 25 35 45 50]
    modified b1
    [ 0 10 25 60 60 60]
    b2
    [[10 20 30]
     [40 50 60]
     [70 80 90]]
    b2[1:3, 1:3] :  [[50 60]
     [80 90]]
    b2[:3, 1:] :  [[20 30]
     [50 60]
     [80 90]]
    b2[1][0:2] :  [40 50]
    modified b2
    [[10 25 35]
     [40 55 65]
     [70 80 90]]
    ```

    

